# 算法设计思想参考文档

## 目录
1. [贪心算法(Greedy)](#贪心算法greedy)
2. [分治算法(Divide and Conquer)](#分治算法divide-and-conquer)
3. [动态规划(Dynamic Programming, DP)](#动态规划dynamic-programming-dp)
4. [回溯算法(Backtracking)](#回溯算法backtracking)
5. [分支限界法(Branch and Bound)](#分支限界法branch-and-bound)
6. [滑动窗口(Sliding Window)](#滑动窗口sliding-window)
7. [双指针(Two Pointers)](#双指针two-pointers)
8. [二分查找(Binary Search)](#二分查找binary-search)
9. [图算法(Graph Algorithms)](#图算法graph-algorithms)
10. [位运算(Bit Manipulation)](#位运算bit-manipulation)
11. [算法选择决策流程](#算法选择决策流程)


## 1. 贪心算法(Greedy)

### 核心思想
每一步都做出当前看起来最优的选择, 期望通过局部最优导致全局最优. 不考虑未来可能的情况, 只关注当前决策.

### 适用场景
- 局部最优能导致全局最优(贪心选择性质)
- 问题具有最优子结构(全局最优解包含局部最优解)
- 问题可以分解为一系列独立的选择

### 典型问题
- 哈夫曼编码
- 活动选择问题
- 最小生成树(Kruskal、Prim算法)
- 单源最短路径(Dijkstra算法)
- 零钱兑换问题(特定条件下)

### 识别特征
- 问题要求最大化/最小化某个指标
- 每一步选择可以独立决策, 不影响后续选择
- 贪心选择后, 问题规模缩小, 且剩余子问题仍具有最优子结构

### 实现思路
1. 定义贪心策略(确定如何选择局部最优)
2. 按贪心策略逐步做出选择
3. 验证最终解是否为全局最优

### 时间复杂度
- 通常为O(nlogn)(排序后贪心选择)
- 或O(n)(线性贪心选择)

### 空间复杂度
- 通常为O(1)或O(n)

### 优缺点
| 优点 | 缺点 |
|------|------|
| 实现简单, 效率高 | 仅适用于特定问题(需严格证明贪心选择性质) |
| 时间复杂度低 | 容易陷入局部最优, 导致全局次优 |
| 空间复杂度低 | 无法回溯调整决策 |

### 示例代码
```java
// 活动选择问题的贪心解法
public int maxActivities(int[] start, int[] end) {
    // 按结束时间排序
    // ... 排序代码 ...

    int count = 1;
    int lastEnd = end[0];

    for (int i = 1; i < start.length; i++) {
        if (start[i] >= lastEnd) { // 贪心选择: 选择结束最早的活动
            count++;
            lastEnd = end[i];
        }
    }

    return count;
}
```


## 2. 分治算法(Divide and Conquer)

### 核心思想
- **分**: 将原问题分解为多个规模较小的子问题
- **治**: 递归解决每个子问题
- **合**: 将子问题的解合并为原问题的解

### 适用场景
- 问题可以分解为独立的子问题(无重叠子问题)
- 子问题的解可以合并为原问题的解
- 问题具有最优子结构

### 典型问题
- 归并排序、快速排序
- 二分查找
- 大整数乘法(Karatsuba算法)
- 最近点对问题
- 矩阵乘法(Strassen算法)

### 识别特征
- 问题可以均匀分解为相似的子问题
- 子问题相互独立(无重叠)
- 需要将子问题的解合并才能得到原问题的解

### 实现思路
1. 分解: 将问题分解为子问题
2. 递归: 递归解决子问题
3. 合并: 合并子问题的解

### 时间复杂度
- 通常为O(nlogn)(通过递归树分析)

### 空间复杂度
- 递归实现: O(logn)(递归栈)+ 问题所需空间
- 迭代实现: O(1)或O(n)

### 优缺点
| 优点 | 缺点 |
|------|------|
| 可以并行处理子问题 | 递归实现可能有栈溢出风险 |
| 时间复杂度通常较低 | 合并步骤可能较复杂 |
| 代码结构清晰 | 对于某些问题, 常数因子可能较大 |

### 示例代码
```java
// 归并排序的分治实现
public void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        // 1. 分解: 找到中点
        int mid = left + (right - left) / 2;

        // 2. 递归: 排序左右子数组
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        // 3. 合并: 合并两个有序子数组
        merge(arr, left, mid, right);
    }
}
```


## 3. 动态规划(Dynamic Programming, DP)

### 核心思想
将原问题分解为重叠子问题, 保存子问题的解, 避免重复计算. 利用最优子结构和无后效性, 通过状态转移求解.

### 适用场景
- 问题具有重叠子问题(子问题会被重复计算)
- 问题具有最优子结构(全局最优解包含局部最优解)
- 问题具有无后效性(已解决的子问题不受后续决策影响)

### 典型问题
- 背包问题(0-1背包、完全背包)
- 最长公共子序列(LCS)
- 最长上升子序列(LIS)
- 最小路径和
- 打家劫舍
- 预测赢家

### 识别特征
- 问题要求最值/计数/存在性
- 可以定义状态(如dp[i]、dp[i][j])描述问题
- 存在状态转移方程, 且状态之间有依赖关系
- 子问题重叠(可通过记忆化避免重复计算)

### 实现思路
1. 定义状态: 确定DP数组的含义
2. 推导状态转移方程: 找出状态之间的递推关系
3. 确定边界条件: 初始化DP数组的基础状态
4. 选择实现方式: 自顶向下(记忆化搜索)或自底向上(迭代)
5. 优化空间: 考虑是否可以优化空间复杂度(如滚动数组)

### 时间复杂度
- 通常为O(n)、O(n²)或O(n³), 远优于暴力法的指数级复杂度

### 空间复杂度
- 二维DP: O(n²)
- 一维DP: O(n)
- 滚动数组优化: O(1)或O(k)(k为常数)

### 优缺点
| 优点 | 缺点 |
|------|------|
| 时间复杂度低, 避免重复计算 | 状态定义和转移方程设计较复杂 |
| 能处理大规模问题 | 需要较多空间存储DP表 |
| 适合处理最值、计数、存在性问题 | 难以调试, 错误难以发现 |

### 示例代码
```java
// 0-1背包问题的动态规划实现
public int knapsack(int W, int[] wt, int[] val) {
    int n = wt.length;
    int[][] dp = new int[n + 1][W + 1];

    // 填充DP表
    for (int i = 1; i <= n; i++) {
        for (int w = 1; w <= W; w++) {
            if (wt[i-1] <= w) {
                // 选择或不选择当前物品
                dp[i][w] = Math.max(val[i-1] + dp[i-1][w - wt[i-1]], dp[i-1][w]);
            } else {
                // 无法选择当前物品
                dp[i][w] = dp[i-1][w];
            }
        }
    }

    return dp[n][W];
}
```


## 4. 回溯算法(Backtracking)

### 核心思想
深度优先搜索(DFS)+ 剪枝. 尝试逐步构建解, 当发现不满足条件时, 回溯到上一步, 尝试其他路径.

### 适用场景
- 组合问题(如子集、组合总和)
- 排列问题(如全排列、N皇后)
- 约束满足问题(如数独、八皇后)
- 路径搜索问题(如迷宫求解)

### 典型问题
- N皇后问题
- 子集和问题
- 括号生成
- 单词搜索
- 电话号码的字母组合

### 识别特征
- 问题要求所有可能的解(而非最优解)
- 解可以通过逐步选择构建
- 需要剪枝(避免无效路径)提高效率

### 实现思路
1. 定义解的结构: 确定解的表示方式
2. 设计递归函数: 包含当前状态、选择路径和结果集
3. 实现选择逻辑: 尝试所有可能的选择
4. 实现剪枝: 排除无效路径
5. 回溯: 撤销选择, 尝试其他路径

### 时间复杂度
- 通常为O(n!)、O(2ⁿ)或O(n^k), 取决于问题规模和剪枝效果

### 空间复杂度
- O(n): 递归栈深度 + 存储结果的空间

### 优缺点
| 优点 | 缺点 |
|------|------|
| 能找到所有解 | 时间复杂度极高 |
| 逻辑清晰, 易于实现 | 对于大规模问题, 效率低下 |
| 可以通过剪枝优化 | 剪枝条件设计较难 |

### 示例代码
```java
// 子集问题的回溯实现
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    backtrack(result, new ArrayList<>(), nums, 0);
    return result;
}

private void backtrack(List<List<Integer>> result, List<Integer> temp, int[] nums, int start) {
    result.add(new ArrayList<>(temp)); // 添加当前子集

    for (int i = start; i < nums.length; i++) {
        temp.add(nums[i]); // 选择当前元素
        backtrack(result, temp, nums, i + 1); // 递归
        temp.remove(temp.size() - 1); // 回溯, 撤销选择
    }
}
```


## 5. 分支限界法(Branch and Bound)

### 核心思想
广度优先搜索(BFS)+ 剪枝. 维护一个优先级队列, 每次选择最有希望的节点扩展. 利用上下界剪枝, 排除不可能产生最优解的分支.

### 适用场景
- 求最优解的搜索问题(如旅行商问题)
- 可以估计解的上下界的问题
- 比回溯更适合大规模问题的最优解搜索

### 典型问题
- 旅行商问题(TSP)
- 0-1背包问题的最优解
- 作业调度问题
- 整数规划问题

### 识别特征
- 问题要求最优解, 且可以估计解的质量
- 适合使用优先级队列管理搜索节点
- 需要剪枝策略排除无效分支

### 实现思路
1. 定义节点结构: 包含当前状态、已用资源、已获收益、预估收益等
2. 设计优先级函数: 确定节点扩展顺序
3. 设计上下界函数: 用于剪枝
4. 使用优先级队列进行BFS搜索
5. 当找到可行解时, 更新最优解并剪枝

### 时间复杂度
- 最坏情况下为O(n!), 但实际中通过剪枝可大幅优化

### 空间复杂度
- O(n): 优先级队列的大小

### 优缺点
| 优点 | 缺点 |
|------|------|
| 能找到最优解 | 实现复杂, 需要设计多个辅助函数 |
| 比回溯更高效(通过优先级和剪枝) | 内存消耗较大 |
| 适合大规模问题 | 上下界函数设计较难 |

### 示例代码
```java
// 简化的分支限界法框架
public int branchAndBound(Problem problem) {
    PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(Node::getPriority));
    pq.offer(new Node(problem.getInitialState()));

    int best = Integer.MIN_VALUE;

    while (!pq.isEmpty()) {
        Node current = pq.poll();

        if (current.isGoal()) {
            best = Math.max(best, current.getValue());
            continue;
        }

        // 剪枝: 如果当前节点的预估收益 <= 已找到的最优解, 跳过
        if (current.getEstimatedValue() <= best) {
            continue;
        }

        // 生成子节点
        for (Node child : current.generateChildren()) {
            pq.offer(child);
        }
    }

    return best;
}
```


## 6. 滑动窗口(Sliding Window)

### 核心思想
维护一个可变长度的窗口(子数组/子串), 通过移动窗口边界(左指针和右指针), 动态调整窗口大小. 仅遍历数组一次, 时间复杂度O(n).

### 适用场景
- 连续子数组/子串问题(如最长/最短、求和、计数)
- 窗口内元素需要满足某种条件(如无重复、和为定值)

### 典型问题
- 最长无重复子串
- 最小覆盖子串
- 滑动窗口最大值
- 长度为k的最大子数组和

### 识别特征
- 问题涉及连续子序列(子数组/子串)
- 可以通过双指针维护窗口, 避免重复计算
- 窗口大小通常动态变化(扩张或收缩)

### 实现思路
1. 初始化左右指针left和right, 均指向数组起始位置
2. 移动右指针, 扩展窗口, 直到窗口不满足条件
3. 移动左指针, 收缩窗口, 直到窗口重新满足条件
4. 更新结果(如最长/最短窗口长度)
5. 重复步骤2-4, 直到右指针到达数组末尾

### 时间复杂度
- O(n): 每个元素最多被访问两次(left和right各一次)

### 空间复杂度
- O(1)或O(k): k为窗口内元素的种类数(如使用哈希表存储窗口内元素)

### 优缺点
| 优点 | 缺点 |
|------|------|
| 时间复杂度低, 仅O(n) | 仅适用于连续子序列问题 |
| 空间复杂度低 | 窗口条件设计较复杂 |
| 实现思路清晰 | 难以处理某些复杂条件 |

### 示例代码
```java
// 最长无重复子串的滑动窗口实现
public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> map = new HashMap<>();
    int max = 0;
    int left = 0;

    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        // 如果字符已存在, 移动左指针到重复字符的下一位
        if (map.containsKey(c)) {
            left = Math.max(left, map.get(c) + 1);
        }
        map.put(c, right); // 更新字符位置
        max = Math.max(max, right - left + 1); // 更新最大长度
    }

    return max;
}
```


## 7. 双指针(Two Pointers)

### 核心思想
使用两个指针(快慢指针、左右指针)遍历数据结构, 协同工作, 减少遍历次数, 优化时间复杂度.

### 适用场景
- 链表问题(如环检测、中点查找)
- 有序数组问题(如两数之和、合并两个有序数组)
- 数组的原地修改(如移除元素)

### 典型问题
- 链表中环的检测(快慢指针)
- 有序数组的两数之和(左右指针)
- 移除元素(快慢指针)
- 反转字符串(左右指针)

### 识别特征
- 问题涉及链表或有序数组
- 可以通过两个指针协同遍历, 减少时间复杂度
- 指针移动方向通常为同向(快慢指针)或相向(左右指针)

### 实现思路
1. 确定指针类型: 快慢指针或左右指针
2. 初始化指针位置: 根据问题类型设置初始位置
3. 设计指针移动规则: 根据条件移动指针
4. 处理结果: 根据指针位置获取最终结果

### 时间复杂度
- O(n): 仅需遍历一次数据结构

### 空间复杂度
- O(1): 仅使用常数级额外空间

### 优缺点
| 优点 | 缺点 |
|------|------|
| 时间复杂度低, 仅O(n) | 仅适用于特定数据结构(链表、有序数组) |
| 空间复杂度低, 仅O(1) | 指针移动规则设计较难 |
| 实现简洁高效 | 难以处理复杂条件 |

### 示例代码
```java
// 有序数组两数之和的双指针实现
public int[] twoSum(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int sum = nums[left] + nums[right];
        if (sum == target) {
            return new int[]{left, right};
        } else if (sum < target) {
            left++; // 和太小, 移动左指针增大和
        } else {
            right--; // 和太大, 移动右指针减小和
        }
    }

    return new int[]{-1, -1}; // 无解
}
```


## 8. 二分查找(Binary Search)

### 核心思想
利用数据的有序性, 每次将搜索范围减半. 时间复杂度O(logn), 远优于线性搜索.

### 适用场景
- 有序数组/有序区间的查找问题
- 可以通过二分缩小搜索范围的问题(如求平方根)

### 典型问题
- 搜索插入位置
- 在旋转排序数组中搜索
- 寻找峰值
- 求平方根

### 识别特征
- 数据有序(或部分有序)
- 问题要求查找特定元素或满足条件的边界值
- 可以通过比较中间元素, 将搜索范围减半

### 实现思路
1. 确定搜索范围: 初始化left和right指针
2. 计算中间位置: mid = left + (right - left) / 2(避免溢出)
3. 比较中间元素与目标值:
   - 相等: 找到目标, 返回结果
   - 大于: 搜索左半部分
   - 小于: 搜索右半部分
4. 重复步骤2-3, 直到left > right(搜索结束)

### 时间复杂度
- O(logn): 每次搜索范围减半

### 空间复杂度
- 迭代实现: O(1)
- 递归实现: O(logn)(递归栈)

### 优缺点
| 优点 | 缺点 |
|------|------|
| 时间复杂度低, 仅O(logn) | 仅适用于有序数据 |
| 空间复杂度低 | 对于小规模数据, 效率提升不明显 |
| 实现简洁 | 难以处理复杂的有序结构 |

### 示例代码
```java
// 标准二分查找实现
public int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2; // 避免溢出
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1; // 搜索右半部分
        } else {
            right = mid - 1; // 搜索左半部分
        }
    }

    return -1; // 未找到
}
```


## 9. 图算法(Graph Algorithms)

### 核心思想
处理图结构(顶点和边)的问题, 包括遍历、最短路径、最小生成树、连通性等.

### 适用场景
- 图结构的问题(如社交网络、地图导航)
- 涉及顶点和边的关系分析

### 典型问题与算法
| 问题类型         | 适用算法                | 特征识别                          |
|------------------|-------------------------|-----------------------------------|
| 图的遍历         | DFS/BFS                 | 需要访问所有顶点/边, 或寻找路径    |
| 单源最短路径     | Dijkstra(非负权)/ Bellman-Ford(负权) | 求从起点到所有顶点的最短路径       |
| 多源最短路径     | Floyd-Warshall          | 求所有顶点对之间的最短路径         |
| 最小生成树       | Kruskal(并查集)/ Prim | 连接所有顶点的最小代价树           |
| 拓扑排序         | Kahn算法/DFS            | 有向无环图(DAG)的顶点排序        |
| 强连通分量       | Tarjan算法/Kosaraju算法 | 有向图中强连通分量的识别           |

### 识别特征
- 问题涉及顶点和边的关系
- 可以抽象为图结构(如网络、关系图)
- 涉及路径、连通性、环等概念

### 实现思路
1. 选择图的表示方式: 邻接矩阵或邻接表
2. 根据问题类型选择合适的图算法
3. 实现算法的核心逻辑
4. 处理边界情况(如孤立顶点、负权边)

### 时间复杂度
| 算法            | 时间复杂度          |
|-----------------|---------------------|
| DFS/BFS         | O(V + E)            |
| Dijkstra        | O((V + E)logV)      |
| Bellman-Ford    | O(VE)               |
| Floyd-Warshall  | O(V³)               |
| Kruskal         | O(ElogE)            |
| Prim            | O((V + E)logV)      |

### 空间复杂度
- O(V + E): 邻接表的存储空间

### 示例代码
```java
// 图的BFS遍历实现
public List<Integer> bfs(int start, List<List<Integer>> adj) {
    List<Integer> result = new ArrayList<>();
    boolean[] visited = new boolean[adj.size()];
    Queue<Integer> queue = new LinkedList<>();

    queue.offer(start);
    visited[start] = true;

    while (!queue.isEmpty()) {
        int current = queue.poll();
        result.add(current);

        for (int neighbor : adj.get(current)) {
            if (!visited[neighbor]) {
                queue.offer(neighbor);
                visited[neighbor] = true;
            }
        }
    }

    return result;
}
```


## 10. 位运算(Bit Manipulation)

### 核心思想
利用二进制位的特性进行运算, 高效处理二进制相关的问题.

### 适用场景
- 二进制表示的问题(如位计数)
- 状态压缩(如使用整数表示集合)
- 位操作优化(如判断奇偶、交换变量)

### 典型问题
- 位1的个数(汉明重量)
- 二进制中1的个数
- 只出现一次的数字(异或运算)
- 子集生成(位掩码)

### 识别特征
- 问题涉及二进制运算或位操作
- 可以用位掩码表示状态, 压缩空间
- 位运算比算术运算更高效(硬件级支持)

### 实现思路
1. 利用位运算符(&、|、^、~、<<、>>、>>>)
2. 设计位掩码表示状态
3. 利用位运算性质优化算法

### 常用位运算技巧
| 技巧                     | 代码                        | 说明                          |
|--------------------------|-----------------------------|-------------------------------|
| 判断奇偶                 | x & 1 == 1                  | 奇数返回1, 偶数返回0          |
| 清除最低位的1            | x & (x - 1)                 | 将x的二进制中最低位的1变为0   |
| 获取最低位的1            | x & -x                      | 仅保留x的二进制中最低位的1    |
| 交换两个变量             | a ^= b; b ^= a; a ^= b;     | 无需额外变量                  |
| 判断是否为2的幂          | x > 0 && (x & (x - 1)) == 0 | 是2的幂返回true               |

### 时间复杂度
- 通常为O(1)或O(n), 取决于问题规模

### 空间复杂度
- O(1): 仅使用常数级额外空间

### 示例代码
```java
// 计算二进制中1的个数(汉明重量)
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        n &= n - 1; // 清除最低位的1
        count++;
    }
    return count;
}
```


## 11. 算法选择决策流程

### 1. 判断问题类型
- 若求**所有解** → 回溯算法
- 若求**最优解** → 贪心/DP/分支限界
- 若求**特定解** → 二分查找/滑动窗口/双指针
- 若求**路径/连通性** → 图算法

### 2. 分析问题特征
| 问题特征 | 可能适用的算法 |
|----------|----------------|
| 连续子序列 | 滑动窗口/DP |
| 有序数据 | 二分查找/双指针 |
| 组合/排列 | 回溯/暴力 |
| 重叠子问题 | DP |
| 局部最优到全局最优 | 贪心 |
| 独立子问题 | 分治 |
| 图结构 | 图算法 |
| 二进制操作 | 位运算 |

### 3. 评估时间复杂度
- 若数据规模较小(n≤20)→ 回溯/暴力
- 若数据规模较大(n≥1e4)→ 必须使用O(n)、O(nlogn)或O(n²)的算法
- 若数据规模非常大(n≥1e5)→ 必须使用O(n)或O(nlogn)的算法

### 4. 验证算法正确性
- 用小例子测试算法逻辑
- 考虑边界情况(空输入、单元素、极值等)
- 验证算法是否满足问题约束

### 5. 选择实现方式
- 优先选择实现简单、易于调试的算法
- 考虑空间复杂度, 避免内存溢出
- 对于时间敏感的问题, 优先选择时间复杂度低的算法


## 总结

本文档总结了常用的算法设计思想, 包括适用场景、识别特征、实现思路、时间复杂度等. 在实际做题时, 可按照以下步骤选择算法:

1. **识别问题类型**: 最值/计数/存在性/所有解/路径等
2. **分析问题特征**: 数据结构、约束条件、规模等
3. **匹配算法特征**: 根据识别特征找到可能适用的算法
4. **验证可行性**: 用小例子测试算法逻辑
5. **优化实现**: 考虑时间和空间复杂度的优化

通过大量练习和总结, 可逐步培养对算法的敏感度, 快速识别问题特征并选择合适的算法.
