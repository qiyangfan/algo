package com.flyingcode.leetcode;

/**
 * 爬楼梯问题
 * 该类提供一个高效的算法, 用于计算爬楼梯的不同方法数.
 * 算法采用动态规划思想, 使用滚动数组优化空间复杂度, 实现了线性时间复杂度.
 * 核心思路是将问题分解为更小的子问题, 利用斐波那契数列的特性求解.
 */
public class Leet0070ClimbStairs {

  /**
   * 算法设计思路:
   * 1. 问题分析: 每次可以爬1步或2步, 到达第n阶的方法数等于到达第n-1阶和第n-2阶的方法数之和
   * 2. 边界条件: 当n=1时, 只有1种方法; 当n=2时, 有2种方法(1+1或2)
   * 3. 动态规划优化: 由于每个状态只依赖前两个状态, 可以使用滚动数组(两个变量)代替完整的dp数组
   * 4. 迭代计算: 从第3阶开始, 逐步计算到第n阶, 每次只更新前两个状态的值
   *
   * 关键技术点:
   * - 动态规划思想: 分解问题为子问题, 利用子问题的解构建原问题的解
   * - 空间优化: 使用O(1)空间复杂度, 避免了O(n)的数组存储
   * - 斐波那契数列特性: 爬楼梯问题本质上是斐波那契数列的应用
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度: O(n), 其中n是楼梯的阶数.
   * 因为需要从第3阶开始, 逐个计算到第n阶, 共进行n-2次迭代, 每次迭代只包含简单的算术运算.
   * - 空间复杂度: O(1).
   * 只使用了三个整型变量(prevPrev, prev, current)来存储中间结果, 不随输入规模变化而变化.
   */

  /**
   * 计算爬楼梯的不同方法数
   *
   * @param n 楼梯的阶数, 范围为1 <= n <= 45
   * @return 到达第n阶的不同方法数
   */
  public int solution(int n) {
    // 边界条件处理: 当n<=2时, 直接返回n
    if (n <= 2) {
      return n;
    }

    // 初始化前两个状态
    int prevPrev = 1; // 到达第i-2阶的方法数 (dp[i-2] = dp[1] = 1)
    int prev = 2; // 到达第i-1阶的方法数 (dp[i-1] = dp[2] = 2)
    int current = 0; // 到达当前阶的方法数

    // 从第3阶开始迭代计算, 直到第n阶
    for (int i = 3; i <= n; i++) {
      // 当前阶的方法数 = 到达第i-1阶的方法数 + 到达第i-2阶的方法数
      current = prevPrev + prev;
      // 更新状态: 前前一阶变为前一阶, 前一阶变为当前阶
      prevPrev = prev;
      prev = current;
    }

    // 返回到达第n阶的方法数
    return prev;
  }
}
