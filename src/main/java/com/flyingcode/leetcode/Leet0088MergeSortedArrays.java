package com.flyingcode.leetcode;

/**
 * 合并两个有序数组
 * 该类提供一个高效的算法, 用于将两个有序整数数组合并到一个有序数组中.
 * 算法采用双指针技术, 从后往前合并, 实现了原地操作, 无需额外空间.
 */
public class Leet0088MergeSortedArrays {

  /**
   * 算法设计思路:
   * 1. 使用三个指针: p1指向nums1有效元素的末尾, p2指向nums2的末尾, p指向合并后nums1的末尾
   * 2. 从后往前遍历两个数组, 比较nums1[p1]和nums2[p2]:
   * - 将较大的元素放入nums1[p]的位置
   * - 对应指针向前移动一位
   * - 合并指针p向前移动一位
   * 3. 当p1或p2小于0时, 退出循环
   * 4. 如果nums2中还有剩余元素, 则直接将其复制到nums1的前面位置
   * 5. 无需处理nums1的剩余元素, 因为它们已经在正确的位置上
   *
   * 关键技术点:
   * - 从后往前合并: 避免覆盖nums1中的未处理元素
   * - 原地操作: 利用nums1的额外空间, 无需创建新数组
   * - 双指针技术: 线性时间复杂度, 高效合并
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度: O(m + n), 其中 m 和 n 分别是nums1和nums2的有效元素个数.
   * 因为只需要遍历两个数组一次, 每个元素最多被访问一次
   * - 空间复杂度: O(1).
   * 只使用了常量级的额外空间(三个整型指针), 所有合并操作都在原地进行
   */

  /**
   * 将两个有序整数数组合并到一个有序数组中
   * nums1的初始长度为m + n, 其中前m个元素是有效的, 后n个元素是0, 用于存储合并结果
   *
   * @param nums1 第一个有序数组, 长度为m + n, 前m个元素有效
   * @param m     nums1中有效元素的个数
   * @param nums2 第二个有序数组, 长度为n, 所有元素有效
   * @param n     nums2中有效元素的个数
   */
  public void solution(int[] nums1, int m, int[] nums2, int n) {
    // 初始化指针, p1指向nums1有效元素的末尾, p2指向nums2的末尾
    int p1 = m - 1;
    int p2 = n - 1;
    // 初始化合并指针p, 指向nums1的末尾(合并后数组的最后一个位置)
    int p = m + n - 1;

    // 从后往前遍历, 比较nums1和nums2中的元素, 将较大的元素放到nums1的末尾
    while (p1 >= 0 && p2 >= 0) {
      if (nums1[p1] > nums2[p2]) {
        // nums1当前元素较大, 放到合并位置
        nums1[p] = nums1[p1];
        p1--;
      } else {
        // nums2当前元素较大或相等, 放到合并位置
        nums1[p] = nums2[p2];
        p2--;
      }
      // 合并位置向前移动一位
      p--;
    }

    // 如果nums2中还有剩余元素, 则直接复制到nums1的前面位置
    // (nums1的剩余元素已经在正确位置, 无需处理)
    while (p2 >= 0) {
      nums1[p] = nums2[p2];
      p2--;
      p--;
    }
  }
}
