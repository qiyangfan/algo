package com.flyingcode.leetcode;

import com.flyingcode.structure.ListNode;

/**
 * 链表环入口检测
 * 该类提供一个高效的算法, 用于检测单链表中是否存在环结构, 并返回环的入口节点.
 * 算法采用经典的快慢指针技术(龟兔赛跑算法), 通过数学推导证明其正确性,
 * 实现了线性时间复杂度和常量空间复杂度, 是解决链表环问题的最优方案之一.
 */
public class Leet0142LinkedListCycleII {

  /**
   * 算法设计思路:
   * 1. 检测链表是否存在环 (快慢指针相遇检测)
   * - 慢指针(slow)每次移动1步, 快指针(fast)每次移动2步
   * - 若链表无环, 快指针会先到达链表末尾, 直接返回null
   * - 若链表有环, 由于快指针速度更快, 最终会在环内追上慢指针, 两者相遇
   *
   * 2. 找到环的入口节点 (数学推导证明)
   * - 变量定义:
   * * a: 链表头到环入口的距离
   * * b: 环入口到快慢指针第一次相遇点的距离
   * * c: 第一次相遇点到环入口的距离
   * * L: 环的长度, L = b + c
   * * k: 第一次相遇时, 快指针在环内绕的圈数 (k ≥ 1, 整数)
   *
   * - 数学推导:
   * * 第一次相遇时, 慢指针走过的距离: a + b
   * * 第一次相遇时, 快指针走过的距离: a + b + kL (快指针绕了k圈)
   * * 由于快指针速度是慢指针的2倍: 2(a + b) = a + b + kL
   * * 化简得: a + b = kL
   * * 代入L = b + c: a + b = k(b + c)
   * * 进一步化简: a = c + (k - 1)(b + c)
   *
   * - 结论:
   * * 链表头到环入口的距离(a), 等于第一次相遇点到环入口的距离(c),
   * 加上环长的整数倍[(k - 1)(b + c)]
   * * 因此, 将慢指针移回链表头, 快指针从相遇点继续移动,
   * 两者以相同速度前进, 最终会在环的入口节点相遇
   *
   * 关键技术点:
   * - 快慢指针技术: 利用环的特性, 快指针会在有限步内追上慢指针
   * - 数学推导: 严格证明了链表头到环入口距离与相遇点到环入口距离的关系
   * - 双阶段查找: 第一阶段检测环的存在, 第二阶段定位环的入口
   * - 常数空间: 只使用两个指针变量, 空间复杂度O(1)
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度: O(n), 其中 n 是链表的节点数量.
   * * 第一阶段(检测环): 快慢指针最多遍历n次, 时间复杂度O(n)
   * * 第二阶段(找环入口): 快慢指针最多遍历n次, 时间复杂度O(n)
   * * 总时间复杂度为O(n) + O(n) = O(n)
   * - 空间复杂度: O(1), 只使用了两个指针变量(slow和fast), 不随输入规模增长.
   */

  /**
   * 检测单链表中是否存在环结构, 并返回环的入口节点
   *
   * @param head 链表的头节点
   * @return 环的入口节点, 若链表无环则返回null
   */
  public ListNode solution(ListNode head) {

    // 边界条件处理: 空链表或只有一个节点的链表一定没有环
    if (head == null || head.next == null) {
      return null;
    }

    // 初始化快慢指针
    // 慢指针(slow): 每次移动1步
    // 快指针(fast): 每次移动2步
    ListNode slow = head;
    ListNode fast = head.next;

    // 第一阶段: 检测链表是否存在环
    // 当快慢指针不相遇时, 持续移动指针
    while (slow != fast) {
      // 快指针到达链表末尾, 说明链表无环
      if (fast == null || fast.next == null) {
        return null;
      }
      // 慢指针移动1步
      slow = slow.next;
      // 快指针移动2步
      fast = fast.next.next;
    }

    // 第二阶段: 找到环的入口节点
    // 数学推导结论: 将慢指针移回链表头, 快指针从相遇点下一个节点开始,
    // 两者以相同速度移动, 最终会在环入口相遇

    // 将慢指针移回链表头
    slow = head;
    // 快指针从相遇点的下一个节点开始移动
    fast = fast.next;

    // 当快慢指针不相遇时, 持续移动指针
    // 此时两者速度相同, 每次都移动1步
    while (slow != fast) {
      // 慢指针从链表头向环入口移动
      slow = slow.next;
      // 快指针从相遇点向环入口移动
      fast = fast.next;
    }

    // 快慢指针相遇, 此时的节点即为环的入口节点
    return slow;
  }
}
