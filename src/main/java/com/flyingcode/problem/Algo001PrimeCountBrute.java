package com.flyingcode.problem;

/**
 * 素数计数 - 暴力解法
 * 该类提供了一个简单的暴力算法, 用于计算从1到给定数字n之间的素数个数
 * 算法采用逐个判断的方式, 对每个数检查其是否为素数
 * 主要特点: 实现简单, 逻辑清晰, 易于理解和调试
 * 适用场景: 小范围素数计数, 教学演示, 入门级应用
 */
public class Algo001PrimeCountBrute {
    /**
     * 算法设计思路:
     * 1. 从2开始遍历到n, 逐个判断每个数是否为素数
     * 2. 对于每个数i, 从2开始检查到其平方根, 判断是否存在因数
     * 3. 如果存在因数, 则该数不是素数; 否则为素数
     * 4. 统计所有素数的个数并返回
     * 5. 优化点: 只需要检查到sqrt(i), 因为因数是成对出现的
     */

    /**
     * 算法复杂度分析:
     * - 时间复杂度:O(n√n), 其中n是输入的上限值
     * 外层循环执行n-1次(从2到n), 内层循环平均执行√i次(从2到√i)
     * - 空间复杂度:O(1), 只使用了常量级别的额外空间
     * 算法只使用了几个变量, 不需要额外的数据结构
     */

    /**
     * 计算从1到n之间的素数个数
     *
     * @param n 上限值, 包含该值
     * @return 素数的个数
     */
    public int solution(int n) {
        // 素数计数器
        int count = 0;

        // 从2开始遍历, 因为1不是素数
        for (int i = 2; i <= n; i++) {
            // 标记当前数字是否为素数
            boolean isPrime = true;

            // 检查到sqrt(i)即可, 因数成对出现
            for (int j = 2; j * j <= i; j++) {
                // 存在因数, 不是素数
                if (i % j == 0) {
                    isPrime = false;
                    // 提前退出循环, 减少不必要的计算
                    break;
                }
            }

            // 统计素数个数
            if (isPrime) {
                count++;
            }
        }

        return count;
    }
}
