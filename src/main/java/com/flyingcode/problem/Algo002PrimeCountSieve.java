package com.flyingcode.problem;

/**
 * 素数计数 - 埃拉托斯特尼筛法
 * 该类提供一个高效的算法, 用于计算从1到给定数字n之间的素数个数
 * 算法采用埃拉托斯特尼筛法, 通过标记合数的方式高效筛选素数
 * 主要特点: 时间复杂度低, 适合大范围素数计数
 */
public class Algo002PrimeCountSieve {
  /**
   * 算法设计思路:
   * 1. 利用素数的定义: 一个大于1的自然数, 除了1和它自身外, 不能被其他自然数整除
   * 2. 初始化一个布尔数组, 假设所有数都是素数
   * 3. 从2开始遍历, 如果当前数是素数, 则标记其所有倍数为合数
   * 4. 遍历完成后, 未被标记的数即为素数
   * 5. 关键优化: 从当前素数的平方开始标记, 避免重复标记
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度:O(n log log n), 其中 n 是输入的上限数值
   * 外层循环执行n次, 内层循环执行次数为n/2 + n/3 + n/5 + ..., 根据数论知识, 该和趋近于n log log n
   * - 空间复杂度:O(n), 需要一个大小为n+1的布尔数组来标记素数
   */

  /**
   * 使用埃拉托斯特尼筛法计算小于等于 n 的素数个数
   *
   * @param n 上限数值(包含n在内)
   * @return 小于等于n的素数个数
   * @throws IllegalArgumentException 当n为负数时抛出异常(未实现, 可扩展)
   */
  public int solution(int n) {
    // 素数计数器: 用于记录找到的素数数量
    int count = 0;

    // 特殊情况处理: 当n < 2时, 没有素数(素数定义: 大于1的自然数)
    if (n < 2) {
      return 0;
    }

    // 布尔数组,isPrime[i] 表示整数i是否为素数
    // 数组索引范围:0到n, 对应数值0到n
    boolean[] isPrime = new boolean[n + 1];

    // 初始化阶段: 假设所有数(从2开始)都是素数
    // 0和1默认false, 因为它们不是素数
    for (int i = 2; i <= n; i++) {
      isPrime[i] = true;
    }

    // 埃氏筛法核心逻辑: 从2开始遍历到n
    // 遍历范围可以优化为i*i <= n, 因为大于sqrt(n)的数如果未被标记, 必然是素数
    for (int i = 2; i <= n; i++) {
      /*
       * 如果i未被标记为合数, 则i是素数
       * 原因:
       * 1. 初始化时所有数都被假设为素数
       * 2. 筛法从2开始, 依次标记每个素数的所有倍数为合数
       * 3. 当遍历到i时, 如果i仍为true, 说明i不是任何小于i的素数的倍数
       * 4. 根据素数定义,i不能被任何小于它的素数整除, 因此i是素数
       */
      if (isPrime[i]) {
        // 素数计数加1
        count++;

        /*
         * 优化点1: 从i*i开始标记, 而非2*i
         * 原因: 对于小于i*i的合数k, 必然存在两个因子a和b(a <= b)
         * 其中a < i, 因此k已经在遍历到a时被标记过了
         * 例如:i=5,i*i=25,2*5=10,3*5=15,4*5=20已在i=2,3时被标记
         * 从i*i开始可以避免重复标记, 提高算法效率
         *
         * 优化点2: 当i*i超过n时, 无需进入内层循环
         * 因为此时i已经是大于sqrt(n)的素数, 其倍数都已被标记
         */
        if ((long) i * i <= n) { // 使用long避免i*i整数溢出
          // 标记所有i的倍数为合数
          // 步长为i, 即i, 2i, 3i, ..., 直到超过n
          for (int j = i * i; j <= n; j += i) {
            isPrime[j] = false;
          }
        }
      }
    }

    // 返回找到的素数个数
    return count;
  }
}
