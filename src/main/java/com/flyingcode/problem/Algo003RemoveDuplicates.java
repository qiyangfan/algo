package com.flyingcode.problem;

/**
 * 移除有序数组中的重复项
 * 该类提供了一个高效的算法, 用于移除有序数组中的重复元素, 同时保持元素的相对顺序不变
 * 算法采用双指针技术, 实现了原地修改数组, 空间复杂度为 O(1)
 */
public class Algo003RemoveDuplicates {

  /**
   * 算法设计思路:
   * 1. 利用数组有序的特性, 重复元素必然相邻
   * 2. 使用双指针技术, 一个指针维护已处理的不重复元素, 另一个指针寻找新的不重复元素
   * 3. 当找到新的不重复元素时, 将其移动到已处理区域的末尾
   * 4. 最终已处理区域的元素就是所有不重复的元素
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度:O(n), 其中 n 是数组的长度.
   * 因为快指针需要遍历整个数组, 慢指针最多移动 n 次, 所以总操作次数是线性的.
   * - 空间复杂度:O(1), 只使用了常量级的额外空间(两个指针变量).
   * 算法是原地修改数组, 没有使用额外的数组或数据结构.
   */

  /**
   * 移除有序数组中的重复项, 返回移除后数组的新长度
   *
   * @param nums 输入的有序整数数组, 注意该数组会被原地修改
   * @return 移除重复项后数组的新长度
   * @throws NullPointerException 如果输入数组为 null
   */
  public int solution(int[] nums) {
    // 获取数组长度
    int n = nums.length;

    // 边界条件处理: 空数组直接返回0
    if (n == 0) {
      return 0;
    }

    /*
     * 慢指针 slow: 始终指向当前已处理的最后一个不重复元素的位置
     * 初始值为0, 表示数组的第一个元素必然是不重复的
     */
    int slow = 0;

    /*
     * 快指针 fast: 用于遍历数组, 寻找新的不重复元素
     * 初始值为1, 从数组第二个元素开始遍历
     */
    for (int fast = 1; fast < n; fast++) {
      // 当快指针指向的元素与慢指针指向的元素不同时
      // 说明找到了一个新的不重复元素
      if (nums[fast] != nums[slow]) {
        // 将慢指针后移一位, 指向新的不重复元素应该存放的位置
        slow++;
        // 将快指针指向的新不重复元素赋值到慢指针位置
        nums[slow] = nums[fast];
      }
      // 如果快指针指向的元素与慢指针指向的元素相同
      // 则说明该元素是重复的, 跳过当前快指针, 继续遍历
    }

    // 最终慢指针指向的是最后一个不重复元素的位置
    // 因此新数组的长度为 slow + 1
    return slow + 1;
  }
}
