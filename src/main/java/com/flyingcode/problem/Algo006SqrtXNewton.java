package com.flyingcode.problem;

/**
 * 使用牛顿迭代法计算平方根
 * 该类提供了一个高效的算法, 用于计算非负整数的平方根
 * 算法采用牛顿迭代法, 通过不断逼近的方式计算平方根, 具有较快的收敛速度
 */
public class Algo006SqrtXNewton {

  /**
   * 算法设计思路:
   * 1. 牛顿迭代法是一种求解方程根的数值方法, 用于求解 f(y) = y*y - x = 0 的正根
   * 2. 迭代公式:y_next = (y_current + x/y_current) / 2, 其中 y_current 是当前迭代的近似值
   * 3. 初始值选择: 对于 x > 1, 选择 1.0 作为初始近似值
   * 4. 迭代终止条件: 当相邻两次迭代结果的差值小于给定的精度阈值时, 停止迭代
   * 5. 结果处理: 将最终的双精度结果转换为整数返回, 即取平方根的整数部分
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度:O(log n), 其中 n 是输入的数值 x
   * 牛顿迭代法具有二次收敛性, 迭代次数与输入规模的对数成正比, 收敛速度非常快
   * - 空间复杂度:O(log n), 由于使用了递归实现
   * 递归调用栈的深度与迭代次数相同, 因此空间复杂度与时间复杂度同阶
   */

  /**
   * 计算非负整数的平方根的整数部分
   *
   * @param x 输入的非负整数, 要求 x >= 0
   * @return x 的平方根的整数部分, 即最大的整数 k 满足 k*k <= x
   */
  public int solution(int x) {
    // 边界条件处理: 当 x 为 0 或 1 时, 平方根就是其本身
    if (x == 0 || x == 1) {
      return x;
    }
    // 调用辅助方法计算双精度平方根, 然后转换为整数返回
    return (int) sqrt(x / 2.0, x);
  }

  /**
   * 使用牛顿迭代法递归计算平方根的双精度近似值
   *
   * @param i 当前迭代的近似值
   * @param x 输入的非负整数, 要求 x >= 0
   * @return x 的平方根的双精度近似值
   */
  public static double sqrt(double i, int x) {
    // 应用牛顿迭代公式:y_next = (y_current + x/y_current) / 2
    double res = (i + x / i) / 2;

    // 迭代终止条件: 相邻两次迭代结果的差值小于精度阈值 0.00001
    if (res * res - x < 0.00001) {
      return res;
    }

    // 递归调用, 继续下一次迭代
    return sqrt(res, x);
  }
}
