package com.flyingcode.problem;

/**
 * 两数之和 - 无序数组暴力解法
 * 该类提供了一种求解两数之和问题的暴力算法, 适用于无序整数数组
 * 算法通过双层循环遍历数组, 找出所有可能的元素对, 直到找到和为目标值的元素对
 */
public class Algo011TwoSumBrute {
  /**
   * 算法设计思路:
   * 1. 采用暴力枚举的方式, 遍历数组中所有可能的元素对
   * 2. 使用双层嵌套循环, 外层循环遍历第一个元素, 内层循环遍历后续元素
   * 3. 对于每对元素, 检查它们的和是否等于目标值
   * 4. 一旦找到符合条件的元素对, 立即返回它们的索引
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度:O(n²), 其中 n 是数组的长度
   * 外层循环执行 n 次, 内层循环在最坏情况下执行 n-1, n-2, ..., 1 次
   * 总操作次数为 n*(n-1)/2, 属于 O(n²) 级别
   * - 空间复杂度:O(1), 只使用了常量级的额外空间
   * 仅创建了一个固定大小的结果数组和循环变量
   */

  /**
   * 在无序数组中查找两个数, 使它们的和等于目标值, 并返回它们的索引
   *
   * @param nums   输入的无序整数数组
   * @param target 目标和值
   * @return 包含两个元素索引的数组, 若未找到则返回默认初始化的数组
   */
  public int[] solution(int[] nums, int target) {
    // 初始化结果数组, 用于存储找到的两个元素的索引
    int[] result = new int[2];

    // 外层循环: 遍历数组中的每个元素, 作为第一个候选元素
    for (int i = 0; i < nums.length; i++) {
      // 内层循环: 遍历当前元素之后的所有元素, 作为第二个候选元素
      for (int j = i + 1; j < nums.length; j++) {
        // 检查当前元素对的和是否等于目标值
        if (nums[i] + nums[j] == target) {
          // 找到符合条件的元素对, 记录它们的索引
          result[0] = i;
          result[1] = j;
          // 立即返回结果, 无需继续遍历
          return result;
        }
      }
    }

    // 若未找到符合条件的元素对, 返回默认初始化的数组
    return result;
  }
}
