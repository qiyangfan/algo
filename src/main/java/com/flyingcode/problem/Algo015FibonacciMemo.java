package com.flyingcode.problem;

/**
 * 斐波那契数列记忆化递归实现
 * 该类提供了一个基于记忆化递归算法的斐波那契数列求解实现
 * 通过引入记忆化数组, 避免了暴力递归中的重复计算问题
 * 斐波那契数列定义为:F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)(n>=2)
 * 记忆化递归是对暴力递归的优化, 大幅提高了时间效率
 */
public class Algo015FibonacciMemo {
  /**
   * 算法设计思路:
   * 1. 基于暴力递归算法, 引入记忆化数组存储已计算的结果
   * 2. 基本情况: 当n<=1时, 直接返回n(F(0)=0, F(1)=1)
   * 3. 记忆化优化: 在计算前检查记忆化数组, 若已存在结果则直接返回, 避免重复计算
   * 4. 递归情况: 对于n>=2, 通过递归调用计算F(n-1)和F(n-2), 并将结果存入记忆化数组
   * 5. 采用自顶向下的递归方式, 结合记忆化技术, 将时间复杂度从O(2^n)降低到O(n)
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度:O(n), 其中n是输入的数值
   * 因为每个斐波那契数只会被计算一次, 之后直接从记忆化数组中获取结果
   * - 空间复杂度:O(n), 其中n是输入的数值
   * 递归调用栈的深度为n, 同时记忆化数组的大小为n+1, 总空间复杂度为线性
   */

  /**
   * 计算斐波那契数列的第n项值, 使用记忆化递归优化
   *
   * @param n 要计算的斐波那契数列项数,n>=0
   * @return 斐波那契数列的第n项值
   */
  public int solution(int n) {
    // 基本情况:n<=1时直接返回n
    if (n <= 1) {
      return n;
    }
    // 创建记忆化数组, 大小为n+1, 用于存储已计算的斐波那契数
    // 初始值为0, 当memo[n]!=0时表示该值已被计算
    int[] memo = new int[n + 1];
    // 调用带记忆化参数的递归方法
    return solution(n, memo);
  }

  /**
   * 带记忆化数组的递归辅助方法
   *
   * @param n    要计算的斐波那契数列项数
   * @param memo 记忆化数组, 用于存储已计算的结果
   * @return 斐波那契数列的第n项值
   */
  private static int solution(int n, int[] memo) {
    // 基本情况:n<=1时直接返回n
    if (n <= 1) {
      return n;
    }
    // 记忆化检查: 如果memo[n]不为0, 说明该值已被计算, 直接返回
    if (memo[n] != 0) {
      return memo[n];
    }
    // 递归计算F(n-1)和F(n-2), 并将结果存入记忆化数组
    memo[n] = solution(n - 1, memo) + solution(n - 2, memo);
    // 返回已计算并存储在记忆化数组中的结果
    return memo[n];
  }
}
