package com.flyingcode.problem;

/**
 * 斐波那契数列双指针迭代实现
 * 该类提供了一个基于双指针迭代算法的斐波那契数列求解实现
 * 通过迭代方式计算斐波那契数, 避免了递归带来的栈溢出风险, 同时具有最优的空间复杂度
 * 斐波那契数列定义为:F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)(n>=2)
 * 双指针迭代是斐波那契数列的最优实现方式之一, 具有线性时间复杂度和常数空间复杂度
 */
public class Algo016FibonacciTwoPointers {
  /**
   * 算法设计思路:
   * 1. 基于斐波那契数列的递推关系, 使用迭代方式自底向上计算
   * 2. 基本情况: 当n<=1时, 直接返回n(F(0)=0, F(1)=1)
   * 3. 迭代情况: 使用两个指针prev和curr分别表示F(n-2)和F(n-1)
   * 4. 通过循环从i=2开始计算到i=n, 每次迭代更新prev和curr的值
   * 5. 使用临时变量next存储当前计算结果, 然后更新指针位置
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度:O(n), 其中n是输入的数值
   * 因为需要循环n-1次(从i=2到i=n), 每次循环执行常数次操作
   * - 空间复杂度:O(1), 只使用了常数级的额外空间(三个变量prev,curr,next)
   * 不依赖于输入规模, 是斐波那契数列的最优空间复杂度实现
   */

  /**
   * 计算斐波那契数列的第n项值, 使用双指针迭代优化
   *
   * @param n 要计算的斐波那契数列项数,n>=0
   * @return 斐波那契数列的第n项值
   */
  public int solution(int n) {
    // 基本情况:n<=1时直接返回n
    if (n <= 1) {
      return n;
    }
    // 初始化双指针:prev表示F(n-2), 初始值为F(0)=0
    int prev = 0;
    // curr表示F(n-1), 初始值为F(1)=1
    int curr = 1;
    // 从i=2开始迭代计算, 直到i=n
    for (int i = 2; i <= n; i++) {
      // 计算当前斐波那契数:F(i) = F(i-2) + F(i-1)
      int next = prev + curr;
      // 更新指针位置:prev移动到curr位置(F(i-1))
      prev = curr;
      // curr移动到next位置(F(i))
      curr = next;
    }
    // 返回最终结果F(n)
    return curr;
  }

}
