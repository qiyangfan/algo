package com.flyingcode.problem;

/**
 * 排列硬币问题的迭代实现
 * 该类提供了一个基于迭代算法的排列硬币问题求解实现
 * 问题描述: 总共有n枚硬币, 将它们摆成一个阶梯形状, 第k行恰好有k枚硬币
 * 算法目标: 找出可以形成完整阶梯行的总行数
 */
public class Algo017ArrangeCoins {
  /**
   * 算法设计思路:
   * 1. 从第1行开始, 每行依次放置1,2,3... 个硬币
   * 2. 每次从总硬币数n中减去当前行所需的硬币数i
   * 3. 检查剩余硬币数是否足够放置下一行(即检查n < i+1)
   * 4. 如果剩余硬币不足, 说明当前行是最后一个完整行, 返回当前行数i
   * 5. 否则继续迭代, 直到找到最后一个完整行
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度:O(√n), 其中n是输入的硬币总数
   * 因为完整阶梯行的总行数k满足k*(k+1)/2 <= n, 所以k约为√(2n), 循环次数为O(√n)
   * - 空间复杂度:O(1), 只使用了常数级的额外空间(一个循环变量i)
   */

  /**
   * 计算可以排列成完整阶梯行的硬币总行数
   *
   * @param n 总硬币数,n>=0
   * @return 可以形成的完整阶梯行的总行数
   */
  public int solution(int n) {
    // 处理n=0的边界情况
    if (n == 0) {
      return 0;
    }

    // 从第1行开始迭代,i表示当前行数
    for (int i = 1; i <= n; i++) {
      // 从总硬币数中减去当前行所需的i个硬币
      n -= i;
      // 检查剩余硬币是否足够放置下一行(i+1个硬币)
      if (n < i + 1) {
        // 如果不足, 当前行i就是最后一个完整行, 返回i
        return i;
      }
    }

    // 理论上不会到达这里, 但为了代码完整性返回0
    return 0;
  }
}
