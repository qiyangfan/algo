package com.flyingcode.problem;

/**
 * 排列硬币问题的二分搜索实现
 * 该类提供了一个基于二分搜索算法的排列硬币问题求解实现
 * 问题描述: 总共有n枚硬币, 将它们摆成一个阶梯形状, 第k行恰好有k枚硬币
 * 算法目标: 找出可以形成完整阶梯行的总行数
 */
public class Algo018ArrangeCoinsBS {
  /**
   * 算法设计思路:
   * 1. 问题可以转化为求解最大的k, 使得1+2+3+...+k <= n
   * 2. 等差数列求和公式:S(k) = k*(k+1)/2
   * 3. 使用二分搜索在1到n的范围内查找最大的k
   * 4. 每次计算中间值mid, 检查S(mid)与n的关系
   * 5. 根据比较结果调整搜索范围:
   * - 如果S(mid) == n,mid就是答案
   * - 如果S(mid) < n, 尝试更大的k(调整左边界)
   * - 如果S(mid) > n, 尝试更小的k(调整右边界)
   * 6. 循环结束时,right指向最后一个满足条件的k值
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度:O(log n), 其中n是输入的硬币总数
   * 因为二分搜索的时间复杂度为对数级别, 每次迭代将搜索范围减半
   * - 空间复杂度:O(1), 只使用了常数级的额外空间
   * 仅需要几个变量来存储左右边界, 中间值和计算结果
   */

  /**
   * 计算可以排列成完整阶梯行的硬币总行数
   *
   * @param n 总硬币数,n>=0
   * @return 可以形成的完整阶梯行的总行数
   */
  public int solution(int n) {
    // 处理n=0的边界情况,0枚硬币无法形成任何完整行
    if (n == 0) {
      return 0;
    }

    // 初始化二分搜索的左右边界
    // 左边界left为1, 因为至少可以形成1行
    // 右边界right为n, 最多不可能超过n行(每行至少1枚硬币)
    int left = 1, right = n;

    // 二分搜索循环, 直到left超过right时结束
    while (left <= right) {
      // 计算中间值mid, 使用left + (right - left) / 2避免直接相加可能导致的整数溢出
      int mid = left + (right - left) / 2;
      // 使用等差数列求和公式计算前mid行需要的硬币总数
      int midSum = (mid * (mid + 1)) / 2;

      // 检查mid行是否可以完整放置
      if (midSum == n) {
        // 如果mid行恰好使用所有硬币, 直接返回mid作为结果
        return mid;
      } else if (midSum < n) {
        // 如果前mid行使用的硬币数小于总硬币数, 说明可以尝试更大的行数
        // 将左边界调整为mid+1, 在更大的范围内继续搜索
        left = mid + 1;
      } else {
        // 如果前mid行使用的硬币数大于总硬币数, 说明行数过大, 需要尝试更小的行数
        // 将右边界调整为mid-1, 在更小的范围内继续搜索
        right = mid - 1;
      }
    }

    // 循环结束时,right就是最后一个可以完整放置的行数
    // 因为当left > right时,right指向的是最大的满足S(k) <= n的k值
    return right;
  }
}
