package com.flyingcode.problem;

/**
 * 合并两个有序数组
 * 该类提供了一个高效的算法, 用于将两个有序数组合并成一个新的有序数组, 同时保持元素的相对顺序不变
 * 算法采用双指针技术, 实现了线性时间复杂度的合并操作
 */
public class Algo021MergeSortedArrays {

    /**
     * 算法设计思路:
     * 1. 利用两个数组都已排序的特性, 每次只需要比较两个数组当前指针位置的元素
     * 2. 使用三个指针技术,i指向nums1当前待处理元素,j指向nums2当前待处理元素,k指向结果数组当前待填充位置
     * 3. 同时遍历两个数组, 比较nums1[i]和nums2[j], 将较小的元素放入result[k], 并移动对应的指针
     * 4. 当任一数组遍历完成后, 将另一个数组的剩余元素直接复制到结果数组中
     * 5. 最终result数组就是两个有序数组合并后的有序数组
     */

    /**
     * 算法复杂度分析:
     * - 时间复杂度:O(m+n), 其中m是nums1的有效长度,n是nums2的有效长度.
     * 因为需要遍历两个数组的所有元素, 每个元素只被处理一次, 所以总操作次数是线性的.
     * - 空间复杂度:O(m+n), 需要创建一个新的数组来存储合并结果, 数组大小等于两个输入数组的有效长度之和.
     * 除了结果数组外, 只使用了常量级的额外空间(三个指针变量).
     */

    /**
     * 合并两个有序数组, 返回合并后的新有序数组
     *
     * @param nums1 第一个有序整数数组, 前m个元素为有效数据
     * @param m     nums1数组中有效元素的个数
     * @param nums2 第二个有序整数数组, 前n个元素为有效数据
     * @param n     nums2数组中有效元素的个数
     * @return 合并后的新有序数组, 长度为m+n
     * @throws NullPointerException 如果输入数组为null
     */
    public int[] solution(int[] nums1, int m, int[] nums2, int n) {
        // 创建结果数组, 用于存储合并后的有序元素
        int[] result = new int[m + n];

        // 初始化三个指针:
        // i: 指向nums1当前待处理的元素位置
        // j: 指向nums2当前待处理的元素位置
        // k: 指向result数组当前待填充的位置
        int i = 0, j = 0, k = 0;

        // 同时遍历两个数组, 比较并选择较小的元素
        // 循环条件: 两个数组都还有未处理的元素
        while (i < m && j < n) {
            // 比较nums1和nums2当前指针位置的元素
            if (nums1[i] < nums2[j]) {
                // 如果nums1的当前元素更小, 将其放入结果数组
                result[k++] = nums1[i++];
            } else {
                // 如果nums2的当前元素更小或相等, 将其放入结果数组
                // 注意: 当元素相等时, 优先选择nums2的元素, 保证算法的稳定性
                result[k++] = nums2[j++];
            }
        }

        // 处理nums1数组的剩余元素
        // 当nums2数组已经遍历完成, 但nums1还有剩余元素时
        // 由于nums1本身是有序的, 直接将其剩余元素依次复制到结果数组
        while (i < m) {
            result[k++] = nums1[i++];
        }

        // 处理nums2数组的剩余元素
        // 当nums1数组已经遍历完成, 但nums2还有剩余元素时
        // 由于nums2本身是有序的, 直接将其剩余元素依次复制到结果数组
        while (j < n) {
            result[k++] = nums2[j++];
        }

        // 返回合并完成的有序数组
        return result;
    }
}
