package com.flyingcode.problem;

/**
 * 查找长度为k的连续子数组的最大平均值
 * 该类提供了一个高效的算法, 用于在整数数组中找到长度为k的连续子数组的最大平均值
 *
 * 重要说明: 子数组必须是连续的, 不能跳过元素或重新排列. 例如, 对于数组[1,2,3,4,5]和k=3,
 * 需要考虑的连续子数组有:[1,2,3],[2,3,4],[3,4,5], 而不是[1,3,5]这样的非连续组合
 *
 * 算法采用滑动窗口技术, 通过一次遍历即可找到最大和, 然后计算平均值, 时间复杂度为 O(n)
 * 适用于需要在大规模数据中快速找到固定长度窗口最大值的场景, 如流量分析, 温度监控等
 */
public class Algo022MaxAverageSubarray {

    /**
     * 算法设计思路:
     * 1. 问题核心: 必须找到连续的k个元素组成的子数组, 不能跳过元素或重新排序
     * 2. 利用连续子数组的特性, 相邻两个窗口之间有k-1个重叠元素, 只有首尾两个元素不同
     * 3. 使用滑动窗口技术, 首先计算第一个窗口(前k个元素)的和作为基准
     * 4. 窗口每次向右滑动一格: 减去离开窗口的最左元素, 加上新进入窗口的最右元素
     * 5. 维护所有窗口和的最大值, 最后除以k得到最大平均值
     */

    /**
     * 算法复杂度分析:
     * - 时间复杂度:O(n), 其中 n 是数组的长度.
     * 首先遍历前k个元素计算初始窗口和, 然后遍历剩余的n-k个元素进行窗口滑动,
     * 总操作次数为 k + (n-k) = n, 是线性的.
     * - 空间复杂度:O(1), 只使用了常量级的额外空间(几个整型变量).
     * 算法不需要额外的数组或数据结构, 直接在原数组上操作.
     */

    /**
     * 查找长度为k的连续子数组的最大平均值
     *
     * 注意: 子数组必须是原数组中连续的k个元素, 保持原有顺序, 不能跳过或重新排列
     *
     * @param nums 输入的整数数组, 包含需要处理的数值
     * @param k    连续子数组的固定长度, 必须满足 1 <= k <= nums.length
     * @return 长度为k的连续子数组的最大平均值, 以double类型返回以保证精度
     * @throws NullPointerException     如果输入数组为 null
     * @throws IllegalArgumentException 如果 k 的值不合法(k <= 0 或 k > nums.length)
     */
    public double solution(int[] nums, int k) {
        // 获取数组长度
        int n = nums.length;

        // 变量 sum: 用于维护当前窗口内所有元素的和
        // 初始值为0, 后续会累加窗口内的元素
        int sum = 0;

        // 计算第一个连续窗口的和: 即索引0到k-1的k个连续元素
        // 这是初始窗口, 后续窗口将在此基础上滑动更新
        for (int i = 0; i < k; i++) {
            sum += nums[i];
        }

        // 变量 maxSum: 用于记录所有窗口中的最大和值
        // 初始化为第一个窗口的和, 后续会不断更新
        int maxSum = sum;

        // 从第k个元素开始, 遍历数组, 每次滑动一个位置
        // 每次滑动都形成一个新的连续窗口, 保持k个元素的连续性
        for (int i = k; i < n; i++) {
            // 滑动窗口的核心操作(O(1)时间更新):
            // 1. 加上新进入窗口的元素:nums[i](当前窗口的最右元素)
            // 2. 减去离开窗口的元素:nums[i - k](前一个窗口的最左元素)
            // 这样就避免了重新计算整个k个元素的和
            sum += nums[i] - nums[i - k];

            // 更新最大和值
            // 如果当前窗口的和大于之前记录的最大和, 则更新最大和
            maxSum = Math.max(maxSum, sum);
        }

        // 返回最大平均值
        // 将最大和除以窗口长度k, 得到最大平均值
        // 使用 (double) 强制类型转换确保除法结果为小数, 保留精度
        return (double) maxSum / k;
    }
}
