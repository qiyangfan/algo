package com.flyingcode.problem;

import com.flyingcode.structure.TreeNode;

/**
 * 使用深度优先搜索计算二叉树的最小深度
 * 该类提供了一个递归算法, 用于计算二叉树的最小深度, 即从根节点到最近叶子节点的最短路径上的节点数量
 * 算法采用深度优先搜索(DFS)策略, 通过递归遍历左右子树来找到最近的叶子节点
 * 适用于需要快速判断树的高度, 平衡性检查, 最短路径查找等场景
 *
 * 重要说明: 最小深度定义为从根节点到最近叶子节点的最短路径上的节点数.
 * 叶子节点是指没有左右子节点的节点. 如果某个节点只有一个子节点,
 * 则必须沿有子节点的路径继续向下, 不能停在当前节点.
 */
public class Algo023MinDepthDFS {

    /**
     * 算法设计思路:
     * 1. 使用深度优先搜索(DFS)递归遍历二叉树的每个节点
     * 2. 基本情况处理: 空树返回0, 叶子节点返回1
     * 3. 递归计算左右子树的深度, 注意处理只有单侧子树的情况
     * 4. 当节点只有左子树或只有右子树时, 必须继续沿有子树的一侧向下遍历
     * 5. 当节点左右子树都存在时, 取较小深度加1作为当前节点的最小深度
     */

    /**
     * 算法复杂度分析:
     * - 时间复杂度:O(n), 其中 n 是二叉树的节点数.
     * 在最坏情况下, 算法需要遍历树的所有节点才能确定最小深度.
     * 例如, 当最小深度在最后一个被访问的叶子节点时, 需要访问所有节点.
     * - 空间复杂度:O(h), 其中 h 是二叉树的高度.
     * 空间消耗主要来自递归调用栈, 递归深度等于树的高度.
     * 最坏情况下(树退化成链表), 空间复杂度为 O(n);
     * 最好情况下(完全平衡树), 空间复杂度为 O(log n).
     */

    /**
     * 计算二叉树的最小深度
     *
     * 最小深度是指从根节点到最近叶子节点的最短路径上的节点数量.
     * 叶子节点定义为没有左右子节点的节点.
     *
     * @param node 二叉树的根节点, 如果为 null 表示空树
     * @return 二叉树的最小深度, 空树返回0, 只有根节点返回1
     */
    public int solution(TreeNode node) {
        // 边界条件处理: 空树的情况
        // 如果节点为 null, 说明当前路径不存在, 返回深度0
        if (node == null) {
            return 0;
        }

        // 叶子节点判断: 左右子节点都为空
        // 叶子节点是递归的终止条件, 深度为1(只包含当前节点)
        if (node.left == null && node.right == null) {
            return 1;
        }

        // 递归计算左子树的最小深度
        // 这一步会一直递归到左子树的底部, 然后逐层返回
        int leftDepth = solution(node.left);

        // 递归计算右子树的最小深度
        // 这一步会一直递归到右子树的底部, 然后逐层返回
        int rightDepth = solution(node.right);

        // 处理只有右子树的情况(左子树为空)
        // 当左子节点为 null 时,leftDepth = 0, 但这不代表找到了叶子节点
        // 因为当前节点不是叶子节点(有右子节点), 必须继续向右遍历
        // 所以应该取右子树的深度, 再加1(当前节点)
        if (node.left == null) {
            return rightDepth + 1;
        }

        // 处理只有左子树的情况(右子树为空)
        // 同理, 当右子节点为 null 时,rightDepth = 0
        // 必须继续向左遍历, 取左子树的深度加1
        if (node.right == null) {
            return leftDepth + 1;
        }

        // 左右子树都存在的情况
        // 取左右子树深度的较小值, 再加1(当前节点)
        // 这样就能找到从当前节点到最近叶子节点的最短路径
        return Math.min(leftDepth, rightDepth) + 1;
    }
}
