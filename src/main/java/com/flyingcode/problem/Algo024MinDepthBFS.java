package com.flyingcode.problem;

import java.util.LinkedList;
import java.util.Queue;

import com.flyingcode.structure.TreeNode;

/**
 * 使用广度优先搜索计算二叉树的最小深度
 * 该类提供了一个迭代算法, 用于计算二叉树的最小深度, 即从根节点到最近叶子节点的最短路径上的节点数量
 * 算法采用广度优先搜索(BFS)策略, 通过队列逐层遍历树, 找到的第一个叶子节点即为最小深度
 * 适用于需要快速找到最近叶子节点的场景, 相比DFS在某些情况下更高效
 *
 * 重要说明: 最小深度定义为从根节点到最近叶子节点的最短路径上的节点数.
 * 叶子节点是指没有左右子节点的节点.BFS的优势是找到的第一个叶子节点必然距离根节点最近.
 *
 * 与DFS的对比:DFS需要遍历所有可能的路径, 而BFS一旦在某一层找到叶子节点就可以立即返回,
 * 在某些树形结构(特别是宽而浅的树)上,BFS可能更高效.
 */
public class Algo024MinDepthBFS {

    /**
     * 算法设计思路:
     * 1. 使用队列实现广度优先搜索(BFS), 按层遍历二叉树
     * 2. 基本情况处理: 空树返回0, 只有根节点返回1
     * 3. 从根节点开始, 逐层将节点加入队列
     * 4. 每次处理一层时, 检查该层的所有节点, 一旦发现叶子节点就立即返回当前深度
     * 5. 将非叶子节点的子节点加入队列, 继续处理下一层
     * 6. 由于BFS按层遍历, 第一个遇到的叶子节点必定是最小深度
     */

    /**
     * 算法复杂度分析:
     * - 时间复杂度:O(n), 其中 n 是二叉树的节点数.
     * 在最坏情况下, 当最小深度位于最后一层时, 需要遍历所有节点.
     * 但在实际应用中,BFS往往不需要遍历所有节点就能找到最小深度.
     * - 空间复杂度:O(w), 其中 w 是二叉树的最大宽度(即某一层的最大节点数).
     * 空间消耗主要来自队列, 队列中最多存储一层的所有节点.
     * 最坏情况下(完全二叉树的最后一层), 空间复杂度为 O(n/2) = O(n);
     * 最好情况下(退化成链表), 空间复杂度为 O(1).
     *
     * 与DFS的空间复杂度对比:
     * - DFS空间复杂度O(h), h为树高; 在退化成链表时为O(n)
     * - BFS空间复杂度O(w),w为树宽; 在完全平衡树时最后一层约为n/2个节点
     * 因此选择DFS还是BFS取决于树的形状: 深而窄的树适合BFS, 宽而浅的树适合DFS
     */

    /**
     * 计算二叉树的最小深度
     *
     * 最小深度是指从根节点到最近叶子节点的最短路径上的节点数量.
     * 叶子节点定义为没有左右子节点的节点.
     *
     * 本方法使用广度优先搜索(BFS)逐层遍历, 一旦发现叶子节点就立即返回当前深度,
     * 这保证了找到的第一个叶子节点就是距离根节点最近的.
     *
     * @param node 二叉树的根节点, 如果为 null 表示空树
     * @return 二叉树的最小深度, 空树返回0, 只有根节点返回1
     */
    public int solution(TreeNode node) {
        // 边界条件处理: 空树的情况
        // 如果节点为 null, 说明树为空, 返回深度0
        if (node == null) {
            return 0;
        }

        // 叶子节点判断: 只有根节点且没有左右子节点
        // 这是单节点树的特殊情况, 深度为1
        if (node.left == null && node.right == null) {
            return 1;
        }

        // 变量 depth: 记录当前遍历到的层数(深度)
        // 初始值为0, 在进入while循环后每次递增
        int depth = 0;

        // 创建队列用于BFS遍历
        // 队列存储待访问的节点, 先进先出(FIFO)保证按层遍历
        Queue<TreeNode> queue = new LinkedList<>();

        // 将根节点加入队列, 作为遍历的起点
        queue.offer(node);

        // BFS主循环: 逐层遍历树
        // 只要队列不为空, 就继续遍历
        while (!queue.isEmpty()) {
            // 每次进入新的一层, 深度加1
            // depth从0开始, 第一次循环后为1, 表示第一层(根节点层)
            depth++;

            // 记录当前层的节点数
            // 这一步很关键: 必须在遍历前保存队列大小
            // 因为遍历过程中会向队列添加新节点(下一层的节点)
            // 使用size确保只处理当前层的节点, 不混入下一层的节点
            int size = queue.size();

            // 遍历当前层的所有节点
            // for循环确保只处理当前层的节点, 不处理新加入的下一层节点
            for (int i = 0; i < size; i++) {
                // 从队列头部取出一个节点进行处理
                // poll方法会移除并返回队列头部的元素
                TreeNode currentNode = queue.poll();

                // 检查当前节点是否为叶子节点(没有左右子节点)
                // 如果是叶子节点, 立即返回当前深度
                // 由于BFS按层遍历, 第一个遇到的叶子节点必定是最小深度
                if (currentNode.left == null && currentNode.right == null) {
                    return depth;
                }

                // 如果当前节点有左子节点, 将其加入队列
                // 加入队列的节点将在下一层被处理
                if (currentNode.left != null) {
                    queue.offer(currentNode.left);
                }

                // 如果当前节点有右子节点, 将其加入队列
                // 加入队列的节点将在下一层被处理
                if (currentNode.right != null) {
                    queue.offer(currentNode.right);
                }
            }
            // 当前层所有节点处理完毕, 进入下一层循环
        }

        // 理论上不应该到达这里
        // 如果树中不存在叶子节点(只有null节点), 则返回当前深度
        // 但实际上正常二叉树必然有叶子节点, 会提前返回
        return depth;
    }
}
