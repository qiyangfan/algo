package com.flyingcode.problem;

/**
 * 最长连续递增子序列长度
 * 该类提供一个高效的算法, 用于查找未排序数组中最长的连续递增子序列的长度
 * 算法采用单次遍历技术, 实现了线性时间复杂度, 空间复杂度为 O(1)
 */
public class Algo025MaxIncSubseq {

  /**
   * 算法设计思路:
   * 1. 维护两个计数器:maxLength 记录全局最长长度,currentLength 记录当前连续递增序列长度
   * 2. 从第二个元素开始遍历数组, 比较当前元素与前一个元素的大小关系
   * 3. 如果当前元素大于前一个元素, 说明连续递增序列继续, 当前长度加1
   * 4. 如果当前元素小于等于前一个元素, 说明连续递增序列中断, 重新开始计数, 当前长度重置为1
   * 5. 每次更新当前长度时, 同步更新全局最大长度, 取两者中的较大值
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度:O(n), 其中 n 是数组的长度.
   * 因为只需要遍历数组一次, 每个元素只访问一次, 所以总操作次数是线性的.
   * - 空间复杂度:O(1), 只使用了常量级的额外空间(两个整型变量).
   * 算法是原地计算, 没有使用额外的数组或数据结构.
   */

  /**
   * 查找数组中最长连续递增子序列的长度
   *
   * 连续递增子序列是指数组中连续位置的元素严格递增的子序列.
   * 例如: 数组 [1,3,5,4,7] 中,[1,3,5] 和 [4,7] 都是连续递增子序列, 最长长度为3.
   *
   * @param nums 输入的整数数组, 可以包含负数, 零和正数, 无需排序
   * @return 最长连续递增子序列的长度; 如果数组为空或null, 返回0
   */
  public int solution(int[] nums) {
    // 边界条件处理: 空数组或null直接返回0
    if (nums == null || nums.length == 0) {
      return 0;
    }

    // 全局最大长度: 记录遍历过程中找到的最长连续递增子序列长度
    // 初始值为1, 因为非空数组至少有一个元素, 最小长度为1
    int maxLength = 1;

    // 当前连续递增序列长度: 记录当前正在遍历的连续递增序列的长度
    // 初始值为1, 表示从数组的第一个元素开始计数
    int currentLength = 1;

    // 从数组的第二个元素开始遍历(索引为1), 与前一元素比较
    for (int i = 1; i < nums.length; i++) {
      // 判断当前元素是否大于前一个元素
      if (nums[i] > nums[i - 1]) {
        // 当前元素大于前一元素, 连续递增序列继续
        // 当前递增序列长度加1
        currentLength++;

        // 更新全局最大长度
        // 比较当前连续递增序列长度和历史最大长度, 取较大值作为新的全局最大长度
        // 这样确保 maxLength 始终保存遍历过程中找到的最长连续递增子序列长度
        maxLength = Math.max(maxLength, currentLength);
      } else {
        // 当前元素小于等于前一元素, 连续递增序列中断
        // 从当前元素重新开始计数, 当前长度重置为1
        // 因为任何单个元素本身都可以视为长度为1的递增序列
        currentLength = 1;
      }
    }

    // 返回遍历结束后记录的全局最大长度, 即最长连续递增子序列的长度
    return maxLength;
  }
}
