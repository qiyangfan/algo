package com.flyingcode.problem;

/**
 * 柠檬水找零
 * 该类提供一个高效的贪心算法, 用于判断在柠檬水摊位是否能够正确给每位顾客找零
 * 柠檬水每杯售价5美元, 顾客只支付5,10或20美元面值的钞票
 * 算法采用贪心策略, 优先使用面值较大的钞票进行找零, 实现了线性时间复杂度, 空间复杂度为 O(1)
 */
public class Algo026LemonadeChange {

  /**
   * 算法设计思路:
   * 1. 使用贪心策略: 在找零时优先使用面值较大的钞票(10美元优于5美元)
   * 2. 维护两个计数器:five 记录5美元钞票数量,ten 记录10美元钞票数量
   * 3. 遍历所有顾客支付的钞票, 根据面值分类处理:
   * - 收到5美元: 直接收入,five 计数器加1
   * - 收到10美元: 需要找零5美元, 检查 five 计数器是否大于0
   * - 收到20美元: 需要找零15美元, 优先使用10+5的组合, 否则使用3张5美元
   * 4. 在任何时候如果不能正确找零, 立即返回 false
   * 5. 成功处理完所有顾客后返回 true
   *
   * 贪心策略正确性证明:
   * - 对于10美元顾客, 只能用一张5美元找零, 策略唯一
   * - 对于20美元顾客, 需要找零15美元, 有两种方案:10+5 或 5+5+5
   * - 优先使用10+5的原因:5美元钞票更通用, 可用于所有找零场景, 而10美元只能用于20美元找零
   * - 因此保留更多5美元钞票可以增加后续找零的成功率
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度:O(n), 其中 n 是顾客人数(bills数组的长度).
   * 因为只需要遍历数组一次, 每位顾客的处理时间是常数时间 O(1), 所以总操作次数是线性的.
   * - 空间复杂度:O(1), 只使用了常量级的额外空间(两个整型变量 five 和 ten).
   * 算法是原地计算, 没有使用额外的数组或数据结构.
   */

  /**
   * 判断是否能够给所有顾客正确找零
   *
   * 柠檬水每杯售价5美元, 顾客排队购买, 每人只买一杯.
   * 顾客只能支付5,10或20美元面值的钞票, 必须正确找零(不能假设顾客有多张钞票可用于找零).
   *
   * @param bills 顾客支付的钞票面值数组, 每个元素为5,10或20
   * @return 如果能给所有顾客正确找零返回 true, 否则返回 false
   */
  public boolean solution(int[] bills) {
    // five: 记录当前拥有的5美元钞票数量
    // ten: 记录当前拥有的10美元钞票数量
    // 不需要记录20美元钞票数量, 因为20美元不用于找零
    int five = 0, ten = 0;

    // 遍历每位顾客支付的钞票
    for (int bill : bills) {
      if (bill == 5) {
        // 顾客支付5美元, 无需找零
        // 5美元钞票数量加1
        five++;
      } else if (bill == 10) {
        // 顾客支付10美元, 需要找零5美元
        // 检查是否有5美元钞票可用于找零
        if (five == 0) {
          // 没有5美元钞票, 无法找零, 返回失败
          return false;
        }
        // 使用一张5美元找零,5美元钞票数量减1
        five--;
        // 收入10美元钞票,10美元钞票数量加1
        ten++;
      } else {
        // 顾客支付20美元, 需要找零15美元
        // 贪心策略: 优先使用10+5的组合, 因为5美元更通用
        if (ten > 0 && five > 0) {
          // 方案1: 使用一张10美元和一张5美元找零(最优方案)
          // 这样可以保留更多5美元钞票用于后续可能的找零需求
          ten--;
          five--;
        } else if (five >= 3) {
          // 方案2: 没有10美元钞票时, 使用三张5美元找零
          // 检查5美元钞票数量是否大于等于3
          five -= 3;
        } else {
          // 既没有10+5的组合, 也没有3张5美元, 无法找零
          return false;
        }
      }
    }

    // 成功处理完所有顾客, 都能正确找零
    return true;
  }
}
