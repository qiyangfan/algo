package com.flyingcode.problem;

import java.util.Arrays;

/**
 * 最大周长三角形
 * 该类提供一个高效的算法, 用于从给定数组中找出可以组成三角形的三个最大边, 并返回其周长
 * 算法采用贪心策略, 结合排序和逆向遍历, 实现了线性时间复杂度(排序后)和常量空间复杂度
 *
 * 三角形构成条件: 对于三条边a, b, c(假设a<=b<=c), 构成三角形的充要条件是a + b > c
 */
public class Algo027MaxPerimeterTriangle {

  /**
   * 算法设计思路:
   * 1. 利用排序将数组按升序排列, 这样可以方便地检查三角形构成条件
   * 2. 采用贪心策略: 从数组末尾开始逆向遍历, 优先考虑较大的边
   * 3. 对于排序后的数组, 如果三个连续的元素nums[i-2], nums[i-1], nums[i]能构成三角形
   * 则它们的周长一定是最大的, 因为:
   * - nums[i]是当前最大的边
   * - nums[i-1]和nums[i-2]是尽可能大的其他两条边
   * - 任何其他组合的周长都不会超过这三条边的和
   * 4. 检查三角形构成条件: 对于边长a, b, c(a<=b<=c), 当且仅当a + b > c时能构成三角形
   * 这里nums[i-2] + nums[i-1] > nums[i]就是三角形不等式的应用
   * 5. 从后向前遍历的优势: 一旦找到满足条件的三条边, 直接返回, 无需继续遍历
   *
   * 贪心策略正确性证明:
   * - 排序后, 对于任意i, 满足nums[i-2] <= nums[i-1] <= nums[i]
   * - 如果nums[i-2], nums[i-1], nums[i]能构成三角形, 则周长为这三边之和
   * - 任何包含nums[i]的其他三角形的另外两条边都<=nums[i-1]和nums[i-2]
   * - 因此这三条边构成的三角形周长一定是最大的
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度:O(n log n), 其中n是数组的长度
   * 排序操作Arrays.sort()的时间复杂度为O(n log n)
   * 排序后的遍历操作最多需要n-2次比较, 时间复杂度为O(n)
   * 因此总时间复杂度由排序决定, 为O(n log n)
   * - 空间复杂度:O(1)或O(log n), 取决于Arrays.sort()的实现
   * 算法本身只使用了常量级的额外空间(几个循环变量)
   * Arrays.sort()对于基本类型int[]使用双轴快排, 空间复杂度为O(log n)(递归栈)
   * 不需要额外的数组或数据结构, 是原地计算
   */

  /**
   * 从数组中找出可以构成三角形的三个最大边, 返回其周长
   *
   * 算法步骤:
   * 1. 对数组进行升序排序, 使得数组元素从小到大排列
   * 2. 从数组末尾开始逆向遍历, 检查每三个连续元素能否构成三角形
   * 3. 对于位置i的三个元素nums[i-2], nums[i-1], nums[i], 检查是否满足三角形不等式
   * 4. 如果找到满足条件的三条边, 立即返回它们的和(即周长)
   * 5. 如果遍历结束仍未找到满足条件的三角形, 返回0
   *
   * 三角形构成原理:
   * 对于三条边a, b, c(假设a <= b <= c), 能构成三角形的充要条件是:a + b > c
   * 排序后的数组中,nums[i-2] <= nums[i-1] <= nums[i]自然成立
   * 因此只需检查nums[i-2] + nums[i-1] > nums[i]即可判断是否能构成三角形
   *
   * @param nums 整数数组, 包含可能作为三角形边长的正整数
   * @return 能构成三角形的最大周长, 如果无法构成三角形则返回0
   */
  public int solution(int[] nums) {
    // 边界条件检查:null或长度小于3的数组无法构成三角形
    if (nums == null || nums.length < 3) {
      return 0;
    }

    // 步骤1: 对数组进行升序排序
    // 排序后, 数组元素从小到大排列, 便于后续的三角形判断
    // 例如: [2,1,2] -> [1,2,2]
    Arrays.sort(nums);

    // 步骤2: 从数组末尾开始逆向遍历, 检查每三个连续元素
    // i从nums.length-1开始, 直到i=2(保证前面还有两个元素nums[i-1]和nums[i-2])
    // 为什么从后向前: 我们优先考虑较大的边, 因为要找最大周长
    for (int i = nums.length - 1; i >= 2; i--) {
      // 步骤3: 检查三角形构成条件
      // 对于排序后的三条边:nums[i-2] <= nums[i-1] <= nums[i]
      // 三角形不等式: 较小的两条边之和大于最大边
      // 即:nums[i-2] + nums[i-1] > nums[i]
      // 等价于:nums[i] < nums[i-1] + nums[i-2](避免可能的整数溢出)
      if (nums[i] < nums[i - 1] + nums[i - 2]) {
        // 步骤4: 找到满足条件的三角形, 返回周长
        // 这三条边构成的三角形周长一定是最大的, 因为:
        // 1. nums[i]是当前可选的最大边
        // 2. nums[i-1]和nums[i-2]是与nums[i]搭配的最大可能的边
        // 3. 从后向前遍历保证我们是先考虑更大的边
        // 周长 = 三条边之和
        return nums[i] + nums[i - 1] + nums[i - 2];
      }
      // 如果不满足三角形条件, 继续向前遍历(i-1)
      // 下一组三条边会包含更小的边, 但可能满足三角形条件
    }

    // 步骤5: 遍历结束仍未找到满足条件的三角形
    // 这种情况发生在数组中的边长无法构成任何三角形时
    // 例如:[1,2,3],1+2不大于3, 无法构成三角形
    // 返回0表示无法构成三角形
    return 0;
  }
}
