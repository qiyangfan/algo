package com.flyingcode.problem;

/**
 * 预测赢家: 动态规划数组实现
 * 本类提供一个算法, 用于判断在双方从数组两端轮流选择数字的游戏中, 先手玩家是否能获胜.
 * 算法使用动态规划方法, 计算在双方都采用最优策略的情况下, 先手玩家是否能保证获胜或平局.
 *
 * 算法设计思路:
 * 1. 使用二维DP数组 `dp[i][j]` 表示当前玩家与对手在子数组 `nums[i...j]` 上的最大分数差
 * 2. 当只有一个元素时 (`i == j`), 当前玩家获得该元素分数, 即 `dp[i][i] = nums[i]`
 * 3. 对于长度大于1的子数组, 当前玩家有两种选择:
 * - 选择起始端数字 `nums[i]`, 则当前玩家的分数差为 `nums[i] - dp[i+1][j]`
 * - 选择末尾端数字 `nums[j]`, 则当前玩家的分数差为 `nums[j] - dp[i][j-1]`
 * - 当前玩家会选择两种情况中的最大值
 * 4. 最终结果为 `dp[0][n-1] >= 0` 时, 先手玩家获胜或平局
 *
 * 算法复杂度分析:
 * - 时间复杂度: O(n^2), 其中 n 为数组的长度.
 * 需要填充一个 n x n 的DP表, 每个元素需要常数时间计算
 * - 空间复杂度: O(n^2), 用于存储DP表
 * 可以优化为 O(n) 空间复杂度, 但为了清晰起见, 这里使用二维数组
 */
public class Algo032PredictWinnerDP {
  /**
   * 判断先手玩家是否能在给定数组的选择游戏中获胜
   *
   * @param nums 输入的整数数组, 每个数字代表一个分数值
   * @return 如果先手玩家在双方都采用最优策略的情况下能获胜或平局, 返回 true; 否则返回 false
   */
  public boolean solution(int[] nums) {
    // 边界条件: 数组为空或为null, 先手玩家无法获胜
    if (nums == null || nums.length == 0) {
      return false;
    }

    // 获取数组长度, 用于创建DP表
    int n = nums.length;
    // 创建二维DP数组, dp[i][j]表示当前玩家与对手在子数组nums[i...j]上的最大分数差
    int[][] dp = new int[n][n];

    // 初始化DP表的对角线元素
    // 当子数组只有一个元素时, 当前玩家获得该元素分数
    for (int i = 0; i < n; i++) {
      dp[i][i] = nums[i];
    }

    // 填充DP表, 从长度为2的子数组开始, 逐步扩展到整个数组
    for (int len = 2; len <= n; len++) {
      // 遍历所有可能的起始索引i, 使得子数组nums[i...j]的长度为len
      for (int i = 0; i <= n - len; i++) {
        // 计算子数组的结束索引j
        int j = i + len - 1;
        // 当前玩家有两种选择: 选择起始端nums[i]或末尾端nums[j]
        // 选择后, 对手成为当前玩家, 所以取负数
        // 取两种选择中的最大值作为当前状态的最优解
        dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
      }
    }

    // 最终结果: dp[0][n-1]表示先手玩家与对手在整个数组上的最大分数差
    // 如果分数差大于等于0, 则先手玩家获胜或平局
    return dp[0][n - 1] >= 0;
  }
}
