package com.flyingcode.problem;

import java.util.ArrayList;
import java.util.List;

/**
 * 字符串搜索算法: Knuth-Morris-Pratt (KMP)
 * 该类提供一个高效的字符串搜索算法, 用于查找模式字符串在主字符串中的所有出现位置.
 * 算法采用部分匹配表(前缀函数)技术, 避免了传统暴力搜索中的不必要回溯, 实现了线性时间复杂度.
 * KMP算法特别适用于在长文本中多次搜索同一模式的场景.
 */
public class Algo035KMP {

  /**
   * 算法设计思路:
   * 1. 预处理模式字符串, 构建部分匹配表(也称为前缀函数), 用于记录模式字符串中每个位置的最长公共前后缀长度
   * 2. 使用双指针技术, 一个指针i遍历主字符串, 一个指针j遍历模式字符串
   * 3. 当字符匹配时, 两个指针同时前进
   * 4. 当字符不匹配时:
   * - 如果j不为0, 则根据部分匹配表将j回溯到合适位置, 避免重新开始匹配
   * - 如果j为0, 则i前进, 继续下一个位置的匹配
   * 5. 当j到达模式字符串末尾时, 找到一个匹配, 记录起始位置, 然后根据部分匹配表继续搜索下一个匹配
   *
   * 关键技术点:
   * - 部分匹配表的构建: 线性时间复杂度, 用于优化匹配失败时的回溯位置
   * - 避免暴力搜索中的O(n*m)时间复杂度, 实现O(n+m)的线性时间复杂度
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度: O(n + m), 其中n是主字符串长度, m是模式字符串长度.
   * 预处理模式字符串构建部分匹配表的时间复杂度为O(m), 主字符串的匹配过程时间复杂度为O(n), 因此总时间复杂度为O(n + m).
   * - 空间复杂度: O(m).
   * 需要额外的数组存储部分匹配表, 数组长度等于模式字符串长度m.
   */

  /**
   * 构建部分匹配表(前缀函数)
   * 部分匹配表用于记录模式字符串中每个位置的最长公共前后缀长度
   * 前缀函数lps[i]的定义: 对于子串P[0..i], 其最长相等的真前缀和真后缀的长度
   * 真前缀: 不包含最后一个字符的前缀, 如P[0..k] (0≤k<i)
   * 真后缀: 不包含第一个字符的后缀, 如P[i-k..i] (0<k≤i)
   *
   * @param pattern 模式字符串, 不能为空
   * @return 部分匹配表, 数组长度等于模式字符串长度, 每个元素表示对应位置的最长公共前后缀长度
   */
  private int[] computePrefix(String pattern) {
    // 模式字符串长度
    int m = pattern.length();
    // 初始化部分匹配表, lps[i]表示模式字符串前i+1个字符的最长公共前后缀长度
    int[] lps = new int[m];
    // len: 当前最长公共前后缀的候选长度, 初始值为0(单个字符无真前后缀)
    int len = 0;
    // i: 当前处理的位置, 从第二个字符开始(索引1)
    int i = 1;

    // 遍历模式字符串, 构建部分匹配表
    while (i < m) {
      // 情况1: 当前字符匹配成功
      // 说明P[i]与当前候选长度位置的字符相同, 可扩展公共前后缀长度
      if (pattern.charAt(i) == pattern.charAt(len)) {
        len++; // 扩展候选长度
        lps[i] = len; // 记录当前位置的最长公共前后缀长度
        i++; // 处理下一个位置
      } else {
        // 情况2: 当前字符匹配失败
        if (len > 0) {
          // 核心回溯逻辑: 当len>0时, 回溯到lps[len-1]位置
          // 理论依据:
          // 1. 已知P[0..len-1] = P[i-len..i-1](len的定义: 当前最长公共前后缀长度)
          // 2. 令k = lps[len-1], 则P[0..k-1] =
          // P[len-k..len-1](lps的定义: lps[len-1]是P[0..len-1]的最长公共前后缀)
          // 3. 由于P[0..len-1] =
          // P[i-len..i-1],
          // 则P[i-k..i-1](P[i-len..i-1]的后缀)等于P[len-k..len-1](P[0..len-1]的后缀)
          // 4. 结合2和3: P[0..k-1] = P[len-k..len-1] = P[i-k..i-1], 因此P[0..k-1] =
          // P[i-k..i-1]
          // 5. k是满足上述条件的最大值, 证明如下(反证法):
          // 假设存在k' > k(即k' > lps[len-1])满足P[0..k'-1] = P[i-k'..i-1]
          // 由于P[0..len-1] = P[i-len..i-1], 则P[i-k'..i-1] = P[len-k'..len-1]
          // 因此P[0..k'-1] = P[len-k'..len-1], 这意味着P[0..len-1]存在长度为k'的公共前后缀
          // 但这与lps[len-1]的定义(P[0..len-1]的最长公共前后缀长度)矛盾, 因为k' > lps[len-1]
          // 所以假设不成立, k是满足条件的最大值
          // 因此, lps[len-1]是下一个最大可能的候选长度
          len = lps[len - 1];
        } else {
          // 当len=0时, 无法回溯, 当前位置的最长公共前后缀长度为0
          lps[i] = 0;
          i++; // 处理下一个位置
        }
      }
    }
    return lps;
  }

  /**
   * 搜索模式字符串在主字符串中的所有出现位置
   * 使用KMP算法实现高效的字符串搜索, 避免不必要的回溯
   * 核心思想: 利用已匹配的信息, 通过部分匹配表指导回溯, 避免从头开始匹配
   *
   * @param text    主字符串, 可以为null或空字符串
   * @param pattern 模式字符串, 可以为null或空字符串
   * @return 模式字符串在主字符串中所有出现位置的索引列表, 若没有匹配则返回空列表
   */
  public List<Integer> solution(String text, String pattern) {
    List<Integer> result = new ArrayList<>();

    // 边界条件处理: 若主字符串或模式字符串为null或空, 返回空列表
    if (text == null || pattern == null || text.isEmpty() || pattern.isEmpty()) {
      return result;
    }

    // 主字符串长度
    int n = text.length();
    // 模式字符串长度
    int m = pattern.length();
    // 构建部分匹配表(前缀函数), 用于指导匹配失败时的回溯
    int[] lps = computePrefix(pattern);

    // i: 主字符串的索引, 从0开始
    int i = 0;
    // j: 模式字符串的索引, 从0开始
    int j = 0;

    // 遍历主字符串进行匹配
    while (i < n) {
      // 步骤1: 检查当前字符是否匹配
      if (pattern.charAt(j) == text.charAt(i)) {
        // 匹配成功: 两个指针同时前进
        i++;
        j++;
      }

      // 步骤2: 无论是否匹配成功, 都检查是否已找到完整匹配
      // 注意: 步骤1中可能已使j达到m(完整匹配)
      if (j == m) {
        // 记录匹配的起始位置, 起始位置 = i - j
        result.add(i - j);
        // 核心操作: 继续搜索下一个匹配
        // 关键理解:
        // - 当找到完整匹配时, i已经指向匹配结束后的下一个位置(因为匹配成功时i++)
        // - j回溯到lps[j-1]: 调整模式串的位置, 利用已匹配的前缀信息
        // - i保持不变: 主串指针不回溯, 继续从当前位置往后处理
        // - 下一次比较是pattern[j]与text[i](i不变但j已调整)
        // - 这是KMP算法的核心优势: 主串指针从不回溯, 保证了线性时间复杂度
        j = lps[j - 1];
        // 理论依据推导:
        // 1. 当j == m时, pattern[0..m-1]已与text[i-m..i-1]完全匹配
        // (此时i指向主串中匹配结束后的下一个位置, j等于模式串长度m)
        // 2. lps[j-1] = lps[m-1], 表示pattern[0..m-1]的最长公共前后缀长度
        // 3. 根据lps定义: pattern[0..lps[m-1]-1] = pattern[m-lps[m-1]..m-1](最长公共前后缀)
        // 4. 证明pattern[m-lps[m-1]..m-1]与text[i-lps[m-1]..i-1]匹配:
        // 因为pattern[m-lps[m-1]..m-1]是已匹配子串pattern[0..m-1]的后缀,
        // 而pattern[0..m-1]与text[i-m..i-1]完全匹配,
        // 所以pattern[m-lps[m-1]..m-1]必然与text[i-lps[m-1]..i-1]匹配
        // 5. 结合3和4: pattern[0..lps[m-1]-1] = pattern[m-lps[m-1]..m-1] =
        // text[i-lps[m-1]..i-1]
        // 即pattern的前缀已与主串当前位置的后缀匹配, 这部分无需重新比较
        // 6. 因此, 下一轮匹配不需要从j=0开始, 直接从j=lps[m-1]开始即可:
        // - 直观理解: 将模式串向右移动, 直到其前缀pattern[0..lps[m-1]-1]与主串的后缀text[i-lps[m-1]..i-1]对齐
        // - 实现方式: 保持主串指针i不变(指向匹配结束后的下一个位置), 将模式串指针j调整为lps[m-1]
        // - 本质: 不是移动模式串的头, 而是将模式串的下一个待匹配字符(j=lps[m-1]位置)对齐到主串的i位置
        // - 为什么正确: 因为pattern[0..lps[m-1]-1]已经通过之前的匹配关系间接确认与text[i-lps[m-1]..i-1]匹配
        // - 下一轮比较: 直接从j=lps[m-1]开始, 比较pattern[j]与text[i]是否匹配
        // - 效果: 避免了重新比较已匹配的前缀, 只需要比较新的字符, 提高了算法效率
        // 7. 普适性证明: 不会跳过任何可能的匹配(无论模式串是否为连续重复字符)
        // - 假设存在一个匹配起始于位置k, 其中 i-m+1 ≤ k ≤ i-lps[m-1]
        // - 则pattern[0..m-1] = text[k..k+m-1]
        // - 由于pattern[0..m-1] = text[i-m..i-1], 所以text[k..k+m-1] = text[i-m..i-1]
        // - 考虑两个匹配的重叠部分, 可得pattern[0..(i-1)-k] = pattern[k-(i-m)..m-1]
        // - 这意味着pattern存在一个长度为(i-1)-k+1 > lps[m-1]的公共前后缀
        // - 与lps[m-1]是pattern[0..m-1]的最长公共前后缀矛盾
        // - 因此假设不成立, 不存在起始于i-m+1到i-lps[m-1]之间的匹配
        // - 所以回溯到lps[m-1]是正确的, 不会跳过任何可能的匹配
        // 8. 效果: 避免了重复比较已匹配的前缀, 提高了算法效率
      }
      // 步骤3: 如果未找到完整匹配, 检查当前是否匹配失败
      // 注意: 只有当j < m时才会执行此分支
      else if (i < n && pattern.charAt(j) != text.charAt(i)) {
        // 当前字符匹配失败, 执行回溯逻辑
        if (j > 0) {
          // 当j>0时, 回溯到lps[j-1]位置
          // 理论依据与computePrefix方法中的回溯逻辑相同:
          // 1. 已匹配的子串为P[0..j-1], 且P[0..j-1] = T[i-j..i-1]
          // 2. 令k = lps[j-1], 则P[0..k-1] = P[j-k..j-1]
          // 3. 因此P[0..k-1] = T[i-k..i-1], 可以直接从k位置继续匹配
          // 4. 这避免了主字符串指针i的回溯, 保证了线性时间复杂度
          j = lps[j - 1];
        } else {
          // 当j=0时, 无法回溯, 主字符串指针i前进到下一个位置
          i++;
        }
      }
    }

    return result;
  }

}
