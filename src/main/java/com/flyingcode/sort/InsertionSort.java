package com.flyingcode.sort;

/**
 * 插入排序
 * 该类提供一个简单高效的排序算法, 用于对整数数组进行排序.
 * 算法采用将元素插入到已排序序列中的方式, 实现稳定排序.
 * 插入排序适用于小规模数据集或基本有序的数据集, 具有良好的性能.
 */
public class InsertionSort {

  /**
   * 算法设计思路:
   * 1. 将数组分为已排序区间和未排序区间, 初始时已排序区间只有第一个元素
   * 2. 从第二个元素开始, 依次处理未排序区间的每个元素
   * 3. 对于当前元素, 保存其值并从已排序区间的末尾开始比较
   * 4. 将已排序区间中大于当前元素的元素向右移动一位
   * 5. 找到合适位置后, 将当前元素插入到该位置
   * 6. 重复上述过程直到所有元素排序完成
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度: O(n^2), 其中 n 是数组长度.
   * - 最坏情况下: 需要进行 n-1 轮插入, 每轮插入最多比较 i 次, 时间复杂度为 O(n^2)
   * - 最好情况下: 数组已经有序, 每轮插入只需要比较 1 次, 时间复杂度为 O(n)
   * - 平均情况下: 时间复杂度为 O(n^2)
   * - 空间复杂度: O(1).
   * - 原地排序算法, 只需要常数级的额外空间
   */

  /**
   * 对整数数组进行插入排序
   *
   * @param arr 待排序的整数数组, 可以为null或空数组
   * @return 排序后的整数数组, 如果输入为null或空数组则直接返回
   */
  public int[] sort(int[] arr) {
    // 边界情况处理: 空数组或长度为1的数组无需排序
    if (arr == null || arr.length <= 1) {
      return arr;
    }

    int n = arr.length;
    // 外层循环控制未排序区间的元素: 从第二个元素开始
    for (int i = 1; i < n; i++) {
      // 保存当前要插入的元素值
      int current = arr[i];
      // j指向已排序区间的最后一个元素
      int j = i - 1;

      // 核心插入逻辑: 从已排序区间末尾向前查找插入位置
      // 当找到第一个不大于current的元素时, 停止查找
      while (j >= 0 && arr[j] > current) {
        // 将大于current的元素向右移动一位
        arr[j + 1] = arr[j];
        j--;
      }

      // 将current插入到正确位置: j+1是退出循环后的正确插入位置
      arr[j + 1] = current;
    }

    return arr;
  }
}
