package com.flyingcode.sort;

/**
 * 选择排序
 * 该类提供一个简单直观的排序算法, 用于对整数数组进行排序.
 * 算法采用每次选择最小元素的方式, 实现不稳定排序.
 * 选择排序是一种原地排序算法, 适用于小规模数据集.
 */
public class SelectionSort {

  /**
   * 算法设计思路:
   * 1. 分区概念: 将数组分为已排序区间和未排序区间, 初始时已排序区间为空
   * 2. 选择最小元素: 遍历未排序区间, 找到最小元素的索引
   * 3. 元素交换: 将最小元素与未排序区间的第一个元素交换位置
   * 4. 扩展已排序区间: 已排序区间向右扩展一位
   * 5. 重复执行: 直到未排序区间为空, 整个数组排序完成
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度: O(n^2), 其中 n 是数组长度.
   * - 无论输入情况如何, 都需要进行 n-1 轮选择
   * - 每轮选择需要比较 n-i 次, 总比较次数为 n(n-1)/2
   * - 最好、平均、最坏情况下时间复杂度均为 O(n^2)
   * - 空间复杂度: O(1).
   * - 原地排序算法, 只需要常数级的额外空间
   */

  /**
   * 对整数数组进行选择排序
   *
   * @param arr 待排序的整数数组, 可以为null或空数组
   * @return 排序后的整数数组, 如果输入为null或空数组则直接返回
   */
  public int[] sort(int[] arr) {
    // 边界情况处理: 空数组或长度为1的数组无需排序
    if (arr == null || arr.length <= 1) {
      return arr;
    }

    int n = arr.length;
    // 外层循环控制已排序区间的边界: 0到i-1为已排序区间
    for (int i = 0; i < n - 1; i++) {
      // 假设未排序区间的第一个元素为最小值
      int minIndex = i;
      // 内层循环遍历未排序区间[i+1, n-1], 找到最小元素的索引
      for (int j = i + 1; j < n; j++) {
        if (arr[j] < arr[minIndex]) {
          // 更新最小元素索引
          minIndex = j;
        }
      }

      // 如果最小元素不是未排序区间的第一个元素, 则交换位置
      if (minIndex != i) {
        // 交换i和minIndex位置的元素
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
      }
    }

    return arr;
  }
}
