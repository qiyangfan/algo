package com.flyingcode.sort;

/**
 * 希尔排序
 * 该类提供一个高效的排序算法, 用于对整数数组进行排序.
 * 算法采用缩小增量排序策略, 是插入排序的改进版本, 实现不稳定排序.
 * 希尔排序通过引入动态步长gap, 打破了插入排序只能相邻比较的限制, 大幅提高了排序效率.
 */
public class ShellSort {

  /**
   * 算法设计思路:
   * 1. 选择增量序列: 采用经典的 n/2, n/4, ..., 1 作为增量序列
   * 2. 多趟排序: 按增量序列个数 k, 对数组进行 k 趟排序
   * 3. 子数组划分: 每趟排序根据当前增量 gap, 将数组逻辑上分成若干间隔为 gap 的子数组
   * 例如: gap=3时, 子数组为 [0,3,6,...], [1,4,7,...], [2,5,8,...]
   * 4. 子数组排序: 对每个子数组执行带有步长gap的插入排序
   * 5. 增量递减: 随着gap逐渐减小, 子数组元素越来越密集, 数组逐渐接近有序
   * 6. 最终排序: 当gap=1时, 执行标准插入排序, 此时数组已基本有序, 排序效率极高
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度: O(n^(1.3-2)), 其中 n 是数组长度.
   * - 具体复杂度取决于增量序列的选择
   * - 本实现采用经典序列, 平均情况约为 O(n^(1.5))
   * - 最好情况: O(n log n) (当数组已基本有序时)
   * - 最坏情况: O(n^2) (当增量序列选择不佳时)
   * - 空间复杂度: O(1).
   * - 原地排序算法, 只需要常数级的额外空间
   */

  /**
   * 对整数数组进行希尔排序
   *
   * @param arr 待排序的整数数组, 可以为null或空数组
   * @return 排序后的整数数组, 如果输入为null或空数组则直接返回原数组引用
   */
  public int[] sort(int[] arr) {
    // 边界情况处理: 空数组或长度为1的数组无需排序
    if (arr == null || arr.length <= 1) {
      return arr;
    }

    int n = arr.length;
    // 生成增量序列: gap从n/2开始, 每次减半, 直到gap=1
    for (int gap = n / 2; gap > 0; gap /= 2) {
      // 对每个元素i (从gap开始), 执行带有步长gap的插入排序
      for (int i = gap; i < n; i++) {
        // 保存当前要插入的元素值
        int current = arr[i];
        // j指向当前元素所在子数组的前一个元素 (间隔为gap)
        int j = i - gap;

        // 核心插入逻辑: 向前查找插入位置
        // 1. 从已排序区间的末尾开始, 向前以gap为步长查找
        // 2. 当找到第一个不大于current的元素时, 停止查找
        // 3. 采用覆盖操作而非交换操作, 提高效率 (覆盖只需1次赋值, 交换需要3次)
        while (j >= 0 && arr[j] > current) {
          // 将大元素向后移动gap步
          arr[j + gap] = arr[j];
          // 向前移动gap步, 继续查找
          j -= gap;
        }

        // 将current插入到正确位置 (j+gap是退出循环后的正确插入位置)
        arr[j + gap] = current;
      }
    }

    return arr;
  }
}
