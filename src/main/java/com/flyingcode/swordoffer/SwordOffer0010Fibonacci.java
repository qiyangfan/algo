package com.flyingcode.swordoffer;

/**
 * 斐波那契数列
 * 该类提供一个高效的算法, 用于计算第n个斐波那契数.
 * 算法采用动态规划思想, 使用滚动数组优化空间复杂度, 实现了线性时间复杂度.
 * 核心思路是利用斐波那契数列的递推关系: F(n) = F(n-1) + F(n-2).
 */
public class SwordOffer0010Fibonacci {

  /**
   * 算法设计思路:
   * 1. 问题分析: 斐波那契数列的定义为 F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) (n>=2)
   * 2. 边界条件: 当n<=1时, 直接返回n
   * 3. 动态规划优化: 由于每个状态只依赖前两个状态, 可以使用滚动数组(两个变量)代替完整的dp数组
   * 4. 迭代计算: 从第2项开始, 逐步计算到第n项, 每次只更新前两个状态的值
   *
   * 关键技术点:
   * - 动态规划思想: 分解问题为子问题, 利用子问题的解构建原问题的解
   * - 空间优化: 使用O(1)空间复杂度, 避免了O(n)的数组存储
   * - 迭代计算: 相比递归实现, 避免了栈溢出风险和重复计算
   */

  /**
   * 算法复杂度分析:
   * - 时间复杂度: O(n), 其中n是斐波那契数的序号.
   * 因为需要从第2项开始, 逐个计算到第n项, 共进行n-1次迭代, 每次迭代只包含简单的算术运算.
   * - 空间复杂度: O(1).
   * 只使用了三个整型变量(prevPrev, prev, current)来存储中间结果, 不随输入规模变化而变化.
   */

  /**
   * 计算第n个斐波那契数
   *
   * @param n 斐波那契数的序号, 范围为0 <= n <= 45
   * @return 第n个斐波那契数
   */
  public int solution(int n) {
    // 边界条件处理: 当n<=1时, 直接返回n
    if (n <= 1) {
      return n;
    }

    // 初始化前两个状态
    int prevPrev = 0; // F(n-2) = F(0) = 0
    int prev = 1; // F(n-1) = F(1) = 1
    int current = 0; // F(n)

    // 从第2项开始迭代计算, 直到第n项
    for (int i = 2; i <= n; i++) {
      // 当前项 = 前一项 + 前前一项
      current = prevPrev + prev;
      // 更新状态: 前前一项变为前一项, 前一项变为当前项
      prevPrev = prev;
      prev = current;
    }

    // 返回第n个斐波那契数
    return current;
  }
}
